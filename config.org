#+Title: Emacs - ayoshi
#+Author: ayoshi

* Options                                                  :noexport:ARCHIVE:
#+options: todo:t html-style:nil
#+html_head: <link rel="stylesheet" type="text/css" href="/css/style.css" />

#+begin_src emacs-lisp :tangle no :results silent
(org-babel-tangle-file "config.org" "config.el" "emacs-lisp")
#+end_src


* Usage

*Emacs-ayoshi* is an Emacs configuration heavily based on an original config by Steckerhalter http://steckerhalter.co.vu/ and [[https://github.com/overtone/emacs-live][Emacs Live]].
 This configuration tries to replace VIM, and uses evil mode heavily. The goal is to make Emacs a much better VIM.

The second goal is to keep everything in one file =config.org= (plus =.emacs= for the initialization) and not as many others to split it over lots of files and directories. Packages are retrieved from the Emacs package repositories on the internet on the first startup.

The source code is hosted on Github: [[https://github.com/ayoshi/steckemacs]]
The original steckemacs source code is hosted  here: [[https://github.com/steckerhalter/steckemacs]]

** Installation

Change to a directory of your choice and clone *steckemacs*:

#+begin_src shell-script
cd <my directory>
git clone https://github.com/ayoshi/steckemacs.git
#+end_src

And symlink =.emacs= into your home directory:

#+begin_src shell-script
cd ~
ln -s <path to the directory from above>/.emacs
#+end_src

That's it. Then you can run emacs and it should pick up the config, install all the packages and make you happy ;)

** How does it work?

I'm using *org-mode* to manage *steckemacs*. =.emacs= (sometimes called *init* file) loads =steckemacs.org=, exports all the code blocks (this process is called "tangling") to =steckemacs.el=. If a block is marked with =:tangle no= it will be skipped. When the tangling is finished =steckemacs.el= is loaded to initialize Emacs.

You can find more information about *Literate Programming* and *org-mode* here: http://orgmode.org/worg/org-contrib/babel/intro.html#literate-programming

The cool thing about this setup is that you can export the same file as documentation to HTML quite easily. Take a look at the [[https://github.com/steckerhalter/steckemacs/blob/master/Makefile][Makefile]] to see how this done with a script. To do it from Org mode directly press =C-c C-e=, choose =h= and then one of the options to produce HTML output.

** Keyboard shortcuts

By using the =key-chord= mode we can avoid having to type C- or M- all the time. It allows for using keys pressed simultaneously and I'm using it quite often.

When I write =fg= as a key combo it means you would have to press =f= and =g= at the same time.

I only describe my custom key combinations currently. To learn the standard Emacs commands, go through the Tutorial =C-h t=, use =C-h b= or =M-x= to see/filter the available commands/shortcuts.

#+NAME: keys-doc
#+begin_src emacs-lisp :var keys=keys :tangle no :results output raw :exports results
(let* ((header (car keys))
       (keys (delq header keys))
       (category))
  (pop keys)
  (mapcar (lambda (l) (if (listp l)
                          (progn
                            (unless (string= (nth 1 l) category)
                              (setq category (nth 1 l))
                              (princ (format "*** %s\n" category))
                              (princ "#+ATTR_HTML: :rules all :cellpadding 4\n")
                              (princ "| / | <r> | | \n"))
                            (princ (format "| # | =%s= | %s |\n" (car l) (nth 2 l))))
                        (princ "|-\n")))
          keys))
(princ "\n")
#+end_src

This table is generated with an Elisp block =keys-doc= from an Org table which is also used in the code [[*Key%20Bindings][further below]].

* Code

** Startup settings

Before we install any package - we need to clean up a bit, set up some sane defaults, and remove small annoyances. All the settings below do not require any additional package.

*** System

This will help modes like flx and grizzl work faster on modern machine. Will set emacs garbage collection treshold to 20MB.
[[http://github.com/lewang/flx#gc-optimization][From flx README]]

#+begin_src emacs-lisp
(setq gc-cons-threshold 20000000)
#+end_src

*** Directories

Set up special directories first

#+begin_src emacs-lisp
(setq
 conf-root-dir     (file-name-as-directory (concat "~/.emacs.d"))
 conf-tmp-dir      (file-name-as-directory (concat conf-root-dir "tmp"))
 conf-etc-dir      (file-name-as-directory (concat conf-root-dir "etc"))
 conf-pscratch-dir (file-name-as-directory (concat conf-tmp-dir  "pscratch"))
 conf-lib-dir      (file-name-as-directory (concat conf-root-dir "lib"))
 conf-autosaves-dir (file-name-as-directory (concat conf-tmp-dir  "autosaves"))
 conf-backups-dir  (file-name-as-directory (concat conf-tmp-dir  "backups"))
 conf-custom-dir   (file-name-as-directory (concat conf-etc-dir  "custom")))

(setq tramp-bkup-backup-directory-info
      '((t conf-backups-dir ok-create full-path prepend-name)))

;; create tmp dirs if necessary
(make-directory conf-root-dir t)
(make-directory conf-etc-dir t)
(make-directory conf-tmp-dir t)
(make-directory conf-autosaves-dir t)
(make-directory conf-backups-dir t)
(make-directory conf-custom-dir t)
(make-directory conf-pscratch-dir t)

#+end_src
*** Default load path

The variable =load-path= lists all the directories where Emacs should look for Elisp files. The first file found is used, therefore the order of the directories is relevant.

=load-path= is documented in the [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Lisp-Libraries.html][Emacs Online Manual]], in chapter *Libraries of Lisp Code for Emacs*. Useful tips are also on [[http://www.emacswiki.org/emacs/LoadPath][EmacsWiki]].

#+begin_src emacs-lisp
(let ((default-directory "~/.emacs.d/elisp/"))
  (unless (file-exists-p default-directory)
    (make-directory default-directory))
  (add-to-list 'load-path default-directory))
#+end_src

Here we create the directory =~/.emacs.d/elisp= if it does not exist, add it to the =load-path=. Doing that any =.el= or =.elc= files in this directory can be required from *emacs*.

*** OS specific settings

**** Linux specific setup

#+begin_src emacs-lisp
(when (eq system-type 'gnu/linux)
  (autoload 'ansi-color-for-comint-mode-on "ansi-color" nil t) ;activate coloring
  (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)   ;for the shell
  (setq x-select-enable-clipboard t)                           ;enable copy/paste from emacs to other apps
  )
#+end_src

**** OSX specific setup

If we're using emacs-macs port ( and beleive me, you should be)

#+begin_src emacs-lisp
;; Specific to the Mac Port by Yamamoto Mitsuharu aka. Railwaycat
;; (not to be confused with the Emacs installed by MacPorts)

;; Emacs Mac has a different set of defaults to Emacs Cocoa/NS
;; I've used NS/Cocoa long enough to consider it the right way,
;; and many of my key bindings extend from that.

;; You may also like the Emacs cocoa keys, and want to use them with
;; Emacs mac, so this is for you.

;; Check for the existence of a function with mac- prefix
(when (symbolp 'mac-control-modifier)
  ;; Re-map modifiers
  (setq mac-control-modifier 'control
        mac-option-modifier 'meta
        mac-command-modifier 'super)
  )

;; Fullscreen mode toggle in emacs mac. This invokes the Kiosk mode
;; fullscreen, ie. only one display is hijacked. not the obnoxious
;; Lion Fullscreen, which kills off all your other screens. Fine if
;; you're just on a lappy. Not nice when you have several screens.
;; Very poor user interface design if you ask me.
;;
;; Emacs mac also has the lion style available for mouse operation,
;; with the Lion top right window button.
;;
;; So you get the best of both worlds.
;;
;; Side-note: Emacs mac port has pixel scrolling, and I'm a sucker for
;; that.

(defvar mac-fullscreen-on nil
  "keep a track of mac-mouse-turn-o(n|ff)-fullscreen, assumes fullscreen is not on")
(defun mac-toggle-fullscreen ()
  "toggle fullscreen mode in Emacs mac (by Yamamoto Mitsuharu)"
  (interactive)
  ;; check we are in the emacs mac build
  (when (functionp 'mac-process-hi-command)
  (if (eq mac-fullscreen-on t)
      (progn
        (mac-mouse-turn-off-fullscreen t)
        (setq mac-fullscreen-on nil)
      )
      (progn
        (mac-mouse-turn-on-fullscreen t)
        (setq mac-fullscreen-on t)
      )
    )))

(when (and (window-system) (fboundp 'mac-mouse-turn-on-fullscreen))
  (global-set-key (kbd "<M-s-return>") 'mac-toggle-fullscreen)
)

;; Bind "Emacs Mac port" keys the same as Emacs NS/Cocoa
(when (symbolp 'mac-control-modifier)

  (global-set-key (kbd "s-s") 'save-buffer)
  (global-set-key (kbd "s-z") 'undo)
  (global-set-key (kbd "s-x") 'cua-cut-region)
  (global-set-key (kbd "s-c") 'cua-copy-region)
  (global-set-key (kbd "s-v") 'cua-paste)
  (global-set-key (kbd "s-w") 'delete-frame)
  (global-set-key (kbd "s-q") 'save-buffers-kill-emacs)
  (global-set-key (kbd "s-k") 'kill-this-buffer)
  (global-set-key (kbd "s-u") 'revert-buffer)
  (global-set-key (kbd "s-a") 'mark-whole-buffer)
  (global-set-key (kbd "s-l") 'goto-line)
  (global-set-key (kbd "s-'") 'switch-window)

;;
;; (global-set-key (kbd "<home>") 'beginning-of-buffer)
;; (global-set-key (kbd "<end>") 'end-of-buffer)

  ;; Navigating around frames, windows & buffers
  (global-set-key (kbd "C-`") 'switch-window)
  (global-set-key (kbd "C-~") 'other-frame)

)
#+end_src


#+begin_src emacs-lisp :tangle yes

#+end_src

#+begin_src emacs-lisp
(when (eq system-type 'darwin)

  (setq default-input-method "MacOSX")

  ;; Make cut and paste work with the OS X clipboard
  (defun copy-from-osx ()
    (shell-command-to-string "pbpaste"))

  (defun paste-to-osx (text &optional push)
    (let ((process-connection-type nil))
      (let ((proc (start-process "pbcopy" "*Messages*" "pbcopy")))
        (process-send-string proc text)
        (process-send-eof proc))))

  (when (not window-system)
    (setq interprogram-cut-function 'paste-to-osx)
    (setq interprogram-paste-function 'copy-from-osx))

  ;; Work around a bug on OS X where system-name is a fully qualified
  ;; domain name
  (setq system-name (car (split-string system-name "\\."))))

  (setq x-select-enable-clipboard t)                           ;enable copy/paste from emacs to other apps

#+end_src

*** Encoding

We'll set all coding systems to UTF-8

#+begin_src emacs-lisp
(set-language-environment 'utf-8)
(set-default-coding-systems 'utf-8)
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
;;disable CJK coding/encoding (Chinese/Japanese/Korean characters)
(setq utf-translate-cjk-mode nil)
#+end_src

*** Basic interface settings

First - let's clean up some visual clutter

#+begin_src emacs-lisp
(setq inhibit-startup-message t
      indicate-buffer-boundaries 'right)             ;fringe markers

(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
(if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
;; Menu bar is not really a hindrance in Mac GUI mode
;; (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
#+end_src

The only way to disable both audio and visual bells.

#+begin_src emacs-lisp
(setq ring-bell-function (lambda () ()))
#+end_src

The following will do some interface changes, and will fix some annoying quirks

#+begin_src emacs-lisp
(setq
 column-number-mode t             ;show the column number
 mouse-yank-at-point t     ;middle click with the mouse yanks at point
 history-length 250        ;default is 30
 confirm-nonexistent-file-or-buffer nil ;don't ask to create a buffer
 vc-follow-symlinks t                   ;follow symlinks automatically
 eval-expression-print-length nil       ;do not truncate printed expressions
 eval-expression-print-level nil        ;print nested expressions
 truncate-lines nil;,
 kill-ring-max 5000                     ;truncate kill ring after 5000 entries
 mark-ring-max 5000                     ;truncate mark ring after 5000 entries
 mouse-autoselect-window -.1            ;window focus follows the mouse pointer
 mouse-wheel-scroll-amount '(1 ((shift) . 5) ((control))) ;make mouse scrolling smooth
 indicate-buffer-boundaries 'right             ;fringe markers
 split-height-threshold 110                   ;more readily split horziontally
 enable-recursive-minibuffers t)

(put 'narrow-to-region 'disabled nil)   ;narrow to region should be enabled by default
#+end_src

*** Default editor settings

These have to be set as defaults.

#+begin_src emacs-lisp
(global-font-lock-mode t)

(minibuffer-depth-indicate-mode 1)

;; Always indent on a newline. This setting affects Evil Insert mode too
(global-set-key (kbd "RET") 'newline-and-indent)

(setq-default
 default-major-mode 'text-mode    ;use text mode per default
 tab-width 4
 indent-tabs-mode nil                   ;use spaces instead of tabs
 c-basic-offset 4                       ;"tab" with in c-related modes
 c-hungry-delete-key t                  ;delete more than one space
 require-final-newline t          ;auto add newline at the end of file
 show-paren-mode t  ; always show matching parens
 show-trailing-whitespace nil
 indicate-empty-lines nil
 fill-column 7
 )
#+end_src

*** Prompt Behavior

#+begin_src emacs-lisp -n -r
(defalias 'yes-or-no-p 'y-or-n-p) (ref:y-or-n)

(setq kill-buffer-query-functions (ref:process-query)
  (remq 'process-kill-buffer-query-function
         kill-buffer-query-functions))
#+end_src

In [[(y-or-n)][line (y-or-n)]] all "yes" or "no" questions are aliased to "y" or "n". We don't really want to type a full word to answer a question from Emacs

Also Emacs should be able to kill processes without asking ([[(process-query)][line (process-query)]]). Got that snippet from: http://www.masteringemacs.org/articles/2010/11/14/disabling-prompts-emacs/
*** Backup and autosave

#+begin_src emacs-lisp
(make-variable-buffer-local 'backup-inhibited)
(setq bkup-backup-directory-info
      `((t ,conf-backups-dir ok-create full-path prepend-name)))

(setq auto-save-file-name-transforms `((".*" ,(concat conf-autosaves-dir "\\1") t)))
(setq backup-by-copying t)
(setq backup-directory-alist `((".*" . ,conf-backups-dir)))
(setq auto-save-list-file-name (concat conf-autosaves-dir "autosave-list"))

(setq delete-old-versions t
      kept-new-versions 6
      kept-old-versions 2
      version-control t)
#+end_src

*** Custom file

Custom file should be under it's own dir.

#+begin_src emacs-lisp
(setq custom-file (expand-file-name (concat conf-custom-dir "emacs-custom.el")))
#+end_src


*** Scratch buffer

#+begin_src emacs-lisp
(setq initial-major-mode 'lisp-interaction-mode
      redisplay-dont-pause t
      column-number-mode t
      echo-keystrokes 0.02
      inhibit-startup-message t
      transient-mark-mode t
      shift-select-mode nil
      require-final-newline t
      truncate-partial-width-windows nil
      delete-by-moving-to-trash nil
      confirm-nonexistent-file-or-buffer nil
      query-replace-highlight t
      next-error-highlight t
      next-error-highlight-no-select t)
#+end_src
*** Mouse should work in terminal

#+begin_src emacs-lisp
(require 'mouse)
#+end_src

Mouse mode must be initialised for each new terminal [[http://stackoverflow.com/a/6798279/27782]]

#+begin_src emacs-lisp
(defun initialise-mouse-mode (&optional frame)
  "Initialise mouse mode for the current terminal."
  (if (not frame) ;; The initial call.
      (xterm-mouse-mode 1)
    ;; Otherwise called via after-make-frame-functions.
    (if xterm-mouse-mode
        ;; Re-initialise the mode in case of a new terminal.
        (xterm-mouse-mode 1))))


;; Evaluate both now (for non-daemon emacs) and upon frame creation
;; (for new terminals via emacsclient).
(initialise-mouse-mode)
(add-hook 'after-make-frame-functions 'initialise-mouse-mode)

(setq mouse-yank-at-point t)

(global-set-key [mouse-4] '(lambda ()
                             (interactive)
                             (scroll-down 1)))

(global-set-key [mouse-5] '(lambda ()
                             (interactive)
                             (scroll-up 1)))
#+end_src

** Install all needed packages

*** Online Check

#+begin_src emacs-lisp
(setq my-onlinep nil)
(unless
    (condition-case nil
        (delete-process
         (make-network-process
          :name "my-check-internet"
          :host "elpa.gnu.org"
          :service 80))
      (error t))
  (setq my-onlinep t))
#+end_src

Try to open a connection to =elpa.gnu.org= and if it succeeds set =my-onlinep= to true. We use this flag later for network related operations.

*** El-Get

#+CAPTION: El-Get Logo
#+NAME: el-get-logo
[[https://raw.github.com/dimitri/el-get/master/logo/el-get.png]]

#+BEGIN_QUOTE
El-Get is designed to simplify this process and allow access to all the various methods of obtaining packages from a single interface. Every package has a recipe that allows you to locate the original source, and that can be updated if the package is moved.
#+END_QUOTE

#+CAPTION: Dimitri Fontaine
#+NAME: fig:dimitri
[[http://tapoueh.org/images/dim.jpeg]]

Dimitri (on the image above, [[fig:dimitri]]) is the clever guy that brougth us El-Get. The code is hosted [[https://github.com/dimitri/el-get][on Github]].

#+begin_src emacs-lisp -n -r
(add-to-list 'load-path "~/.emacs.d/el-get/el-get")
(setq el-get-install-skip-emacswiki-recipes t) (ref:wiki)
(unless (require 'el-get nil 'noerror)
  (if my-onlinep
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.github.com/dimitri/el-get/master/el-get-install.el")
      (goto-char (point-max))
      (eval-print-last-sexp))
    (error "El-Get is not installed and we are unable to download it without an internet connection: cannot continue")))
#+end_src

This sets up the load path and fetches and evaluates the stable El-Get branch if not already loaded (as described [[https://github.com/dimitri/el-get#basic-setup][on Github]]). In line [[(wiki)]] we make sure El-Get doesn't load all the Wiki recipes as we don't use them.

#+begin_src emacs-lisp :results silent
(setq el-get-sources
      '(
        ;;(:name company-cider
        ;;       :type github
        ;;       :pkgname "steckerhalter/company-cider"
        ;;       :prepare (eval-after-load 'company '(add-to-list 'company-backends 'company-cider)))
        (:name eval-sexp-fu
               :type http
               :url "http://www.emacswiki.org/emacs/download/eval-sexp-fu.el")
        (:name helm-google
               :type git
               :url "https://github.com/steckerhalter/helm-google")
        (:name magit-filenotify
               :type git
               :url "https://github.com/magit/magit-filenotify")
        ;; TODO: fix the package
        ;;(:name evil-extra-operator
        ;;       :type github
        ;;       :pkgname "Dewdrops/evil-extra-operator")
        ;;(:name evil-exchange
        ;;       :type github
        ;;       :features evil-exchange
        ;;       :pkgname "Dewdrops/evil-exchange")
        ;;(:name evil-plugins
        ;;       :type github
        ;;       :features evil-plugins
        ;;       :pkgname "tarao/evil-plugins")
        ;;(:name powerline
        ;;       :type github
        ;;       :pkgname "milkypostman/powerline")
        ;;(:name emacs-soothe-theme
        ;;       :type github
        ;;       :after (add-to-list 'custom-theme-load-path "~/.emacs.d/el-get/emacs-soothe-theme")
        ;;       :pkgname "milkypostman/emacs-soothe-theme")
        (:name replace-colorthemes
               :type github
               :after (add-to-list 'custom-theme-load-path "~/.emacs.d/el-get/replace-colorthemes")
               :pkgname "emacs-jp/replace-colorthemes")
        ))
#+end_src

These are simple El-Get recipes that will either fetch single Elisp files or clone a Git repo.

#+begin_src emacs-lisp
(setq my-el-get-packages
      (append
       '()
       (mapcar 'el-get-source-name el-get-sources)))

(el-get 'sync my-el-get-packages)
#+end_src

The sync function expects the package names which are extracted from =el-get-sources=. El-Get does the magic and gets the packages specified in =el-get-sources=.

*** Packages

#+begin_src emacs-lisp
   (add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/"))
   (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
   (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/"))
#+end_src

This adds two remote package repositories. The repo from the FSF is already included in Emacs 24 (see http://elpa.gnu.org/).

The best repository by far is [[http://melpa.milkbox.net/][MELPA]]. It builds packages directly from upstream source code. There's a nice [[https://twitter.com/melpa_emacs][Twitter Feed]] showing the packages that have been updated, which is great to discover new modes.

To get the latest org-mode I also add the repo from [[http://orgmode.org/][org-mode.org]].

#+begin_src emacs-lisp
(setq my-packages
      '(ack-and-a-half
        ace-jump-mode
        ag
        auto-compile
        evil
        surround
        ert-modeline
        evil-indent-textobject
        evil-leader
        evil-nerd-commenter
        evil-matchit
        evil-tabs
        exec-path-from-shell
        apache-mode
        auto-dim-other-buffers
        auto-save-buffers-enhanced
        back-button
        buffer-move
        cider
        creole-mode
        clojure-mode
        company
        company-jedi
        csv-mode
        dash
        dash-at-point
        deft
        dired+
        discover
        diff-hl
        elpy
        erc-hl-nicks
        expand-region
        fasd
        fixmee
        flycheck
        flx-ido
        geben
        gist
        grandshell-theme
        sublime-themes
        grizzl
        haskell-mode
        hide-comnt
        hideshowvis
        hideshow-org
        highlight
        helm
        helm-descbinds
        helm-gtags
        helm-git
        helm-projectile
        helm-swoop
        highlight-symbol
        htmlize
        iedit
        ido-vertical-mode
        ido-ubiquitous
        ido-hacks
        ibuffer-vc
        jinja2-mode
        js2-mode
        json-mode
        json-reformat
        key-chord
        markdown-mode+
        melpa-upstream-visit
        mmm-mode
        move-text
        multi-term
        multiple-cursors
        nrepl-eval-sexp-fu
        org
        ;;org-mobile-sync
        powerline
        ;;yphp-eldoc
        php-mode
        popup
        popwin
        projectile
        pretty-symbols
        pos-tip
        rainbow-mode
        rainbow-delimiters
        robe
        restclient
        sequential-command
        skewer-mode
        smart-mode-line
        smartparens
        smex
        visual-regexp
        vlf
        volatile-highlights
        web-mode
        yaml-mode
        yari
        solarized-theme
        color-theme-sanityinc-solarized
        color-theme-sanityinc-tomorrow
        ))
#+end_src

Quite a big list of packages. When Emacs starts up the first time it takes quite a while to install all of them.

#+begin_src emacs-lisp
(when my-onlinep
  (package-refresh-contents)
  (cl-loop for p in my-packages
           unless (package-installed-p p)
           do (package-install p)))
#+end_src

This part first checks if there is an internet connection. If true it refreshes the package archive cache and goes on to install all the packages that are not yet installed.

** Post-package initialization

Some things should be ran before everything else, but they require side packages, available in repositories.

**** Ensure OSX version honors PATH added from shell

#+begin_src emacs-lisp
(when (eq system-type 'darwin)
  (exec-path-from-shell-initialize))
#+end_src

** Set up key bindings

#+begin_src emacs-lisp
(defvar my-keys-minor-mode-map (make-keymap) "my-keys-minor-mode keymap.")
#+end_src

This is a custom keymap. It is used for a [[my-keys-minor-mode][minor mode that is activated at the end]]. This is the only way I know of to make sure no other minor modes to these override special keys. Setting a global key will not suffice.

#+begin_src emacs-lisp
(key-chord-mode 1)
(setq key-chord-two-keys-delay 0.05)
#+end_src

#+BEGIN_QUOTE
Key-chord lets you bind commands to combination of key-strokes. Here a "key chord" means two keys pressed simultaneously, or a single key quickly pressed twice.
#+END_QUOTE

The source code can be found on [[http://www.emacswiki.org/emacs/key-chord.el][EmacsWiki]].

We need to turn the mode on here so that we can map keys further below. We lower the delay so that chords are not triggered too easily.

#+NAME: gen-keys
#+begin_src emacs-lisp :var keys=keys :results output :tangle no :exports none :colnames nil
(mapcar (lambda (l)
          (let* ((key (car l))
                 (def
                  (cond ((string-match "^[[:alnum:]]\\{2\\}$" (format "%s" key))
                         (format "key-chord-define-global \"%s\"" key))
                        (t
                         (format "global-set-key (kbd \"%s\")" key)))
                  )
                 (command (car (last l))))
            (princ (format "(%s %s)\n" def command))))
        keys)
#+end_src

#+begin_src emacs-lisp :noweb yes :results silent
<<gen-keys()>>
#+end_src

The code for the keys is generated from data in an Org table named =keys= using a bit of Elisp code =gen-keys= and is spit out inside a code block via [[http://orgmode.org/manual/noweb.html][Noweb syntax]]. The same data is also used in the [[Keyboard%20shortcuts][Keyboard shortcuts]] section to generate the documentation. I'd like to be able to have only one place to change key information and have it updated wherever necessary.

#+begin_src emacs-lisp
(define-key key-translation-map (kbd "C-t") (kbd "C-p"))
(define-key my-keys-minor-mode-map (kbd "<C-return>") 'helm-mini)
#+end_src

=C-t= is translated to =C-p= (move up), this helps me with navigating using the [[http://en.wikipedia.org/wiki/Dvorak_Simplified_Keyboard][Dvorak keyboard layout]].
=my-keys-minor-mode-map= is used to set =C-return= in this case in a way so that other minor modes cannot override it.

**** Emacs Key definition table                                    :noexport:
#+TBLNAME: keys
| Combo             | Category    | Desciption                                                | Command                                                     |
|-------------------+-------------+-----------------------------------------------------------+-------------------------------------------------------------|
| C-h x             | General     | Kill emacs (including the daemon if it is running)        | (lambda () (interactive) (shell-command "pkill emacs"))     |
| C-c n             | General     | Show file name + path, save to clipboard                  | 'show-file-name                                             |
| C-x a s           | General     | Toggle auto saving of buffers                             | 'auto-save-buffers-enhanced-toggle-activity                 |
| C-c d             | General     | Change dictionary                                         | 'ispell-change-dictionary                                   |
| C-c C-f           | General     | Toggle flyspell mode (spellchecking)                      | 'flyspell-mode                                              |
| C-S-p             | General     | Sublime-like command palette (execute command)            | 'sublime-csp                                                |
| M-x               | General     | Smex (execute command)                                    | 'smex                                                       |
| M-X               | General     | Smex (execute major mode command)                         | 'smex-major-mode-commands                                   |
| M-X               | General     | Smex (execute major mode command)                         | 'smex-major-mode-commands                                   |
| C-h C-h           | General     | Helm M-x (execute command)                                | 'helm-M-x                                                   |
| C-h h             | General     | Helm navigate project files                               | 'helm-projectile                                            |
| <C-S-iso-lefttab> | General     | Helm for files                                            | 'helm-for-files                                             |
| C-h ,             | General     | Helm: find commands, functions, variables and faces       | 'helm-apropos                                               |
| C-h .             | General     | Helm: Emacs info manual                                   | 'helm-info-emacs                                            |
| C-h 4             | General     | Helm: Elisp info manual                                   | 'helm-info-elisp                                            |
| C-h 3             | General     | Helm: Locate an Elisp library                             | 'helm-locate-library                                        |
| C-h C-p           | General     | Open file                                                 | 'find-file                                                  |
| cg                | General     | Customize group                                           | 'customize-group                                            |
| C-c m             | Interface   | Toggle the menu bar                                       | 'menu-bar-mode                                              |
| s--               | Interface   | Decrease the font size                                    | 'text-scale-decrease                                        |
| s-=               | Interface   | Increase the font size                                    | 'text-scale-increase                                        |
| ln                | Interface   | Show/hide the line numbers                                | 'linum-mode                                                 |
| C-x C-u           | Internet    | Prompt for URL and insert contents at point               | 'my-url-insert-file-contents                                |
| C-c C-w           | Internet    | Browse URL under cursor                                   | 'browse-url-at-point                                        |
| C-z               | Editing     | Undo - but do not trigger redo                            | 'undo-only                                                  |
| <M-f10>           | Editing     | Move line or region up                                    | 'move-text-up                                               |
| <M-f9>            | Editing     | Move line or region down                                  | 'move-text-down                                             |
| C-S-c C-S-c       | Editing     | Edit region with multiple cursors                         | 'mc/edit-lines                                              |
| C-<               | Editing     | Multiple cursors up                                       | 'mc/mark-previous-like-this                                 |
| C->               | Editing     | Multiple cursors down                                     | 'mc/mark-next-like-this                                     |
| C-*               | Editing     | Mark all like "this" with multiple cursors                | 'mc/mark-all-like-this                                      |
| vr                | Editing     | Visual regexp/replace                                     | 'vr/replace                                                 |
| i9                | Editing     | Toggle electric indent mode                               | 'electric-indent-mode                                       |
| ac                | Editing     | Align nearby elements                                     | 'align-current                                              |
| C-8               | Editing     | Select symbol under cursor, repeat to expand              | 'er/expand-region                                           |
| M-8               | Editing     | Contract the current selection                            | 'er/contract-region                                         |
| M-W               | Editing     | Delete region (but don't put it into kill ring)           | 'delete-region                                              |
| fc                | Editing     | Toggle flycheck mode                                      | 'flycheck-mode                                              |
| C-c q             | Editing     | Toggle word wrap                                          | 'auto-fill-mode                                             |
| C-c w             | Editing     | Cleanup whitespaces                                       | 'whitespace-cleanup                                         |
| C-h C-v           | Editing     | Toggle visual line mode                                   | 'visual-line-mode                                           |
| C-h TAB           | Editing     | Indent the whole buffer                                   | 'my-indent-whole-buffer                                     |
| C-=               | Editing     | Expand Region                                             | 'er/expand-region                                           |
| C-?               | Source      | Go to definition of function or variable at point         | 'my-find-function-or-variable-at-point                      |
| C-h C-f           | Source      | Go to the definition of the function under cursor         | 'find-function-at-point                                     |
| M-5               | Source      | Helm select etags                                         | 'helm-etags-select                                          |
| M-6               | Source      | Find tag in a new window                                  | 'find-tag-other-window                                      |
| C-h C-0           | Source      | Edebug defun at point                                     | 'edebug-defun                                               |
| C-h C-b           | Source      | Evaluate the current buffer                               | 'eval-buffer                                                |
| C-h C-e           | Source      | Toggle debug on error                                     | 'toggle-debug-on-error                                      |
| C-h C-d           | Directory   | Open dired in current file location                       | 'dired-jump                                                 |
| sb                | Directory   | Open the speedbar                                         | 'speedbar                                                   |
| C-c T             | Directory   | Open terminal in current directory                        | (lambda () (interactive) (my-open-terminal nil))            |
| C-c t             | Directory   | Open terminal in current project root                     | (lambda () (interactive) (my-open-terminal t))              |
| C-h C-/           | Directory   | Use fasd to navigate to a file or directory               | 'fasd-find-file                                             |
| C-h C-s           | Buffers     | Save the current buffer                                   | 'save-buffer                                                |
| C-c r             | Buffers     | Revert a buffer to the saved state                        | 'revert-buffer                                              |
| C-x C-b           | Buffers     | use ido to switch buffers                                 | 'ido-switch-buffer                                          |
| <f6>              | Buffers     | Kill current buffer                                       | (lambda () (interactive) (kill-buffer (buffer-name)))       |
| <f8>              | Buffers     | Switch to "other" buffer                                  | (lambda () (interactive) (switch-to-buffer nil))            |
| jn                | Buffers     | Switch to "other" buffer                                  | (lambda () (interactive) (switch-to-buffer nil))            |
| fv                | Buffers     | Kill current buffer                                       | (lambda () (interactive) (kill-buffer (buffer-name)))       |
| sv                | Buffers     | Save the current buffer                                   | 'save-buffer                                                |
| sc                | Buffers     | Switch to scratch buffer                                  | (lambda () (interactive)(switch-to-buffer "*scratch*"))     |
| <f9>              | Buffers     | Split window and show/hide last buffer                    | 'my/split-window                                            |
| C-h C-SPC         | History     | Helm show the kill ring                                   | 'helm-show-kill-ring                                        |
| C-h SPC           | History     | Helm show all mark rings                                  | 'helm-all-mark-rings                                        |
| C-3               | History     | Go backward in movement history                           | 'back-button-local-backward                                 |
| C-4               | History     | Go forward in movement history                            | 'back-button-local-forward                                  |
| M-2               | Occur       | Show all symbols like the one cursor is located at        | 'highlight-symbol-occur                                     |
| M-3               | Occur       | Previous symbol like the one the cursor is on             | (lambda () (interactive) (highlight-symbol-jump -1))        |
| M-4               | Occur       | Next symbol like the one the cursor is on                 | (lambda () (interactive) (highlight-symbol-jump 1))         |
| M-9               | Occur       | Helm search for occurences in open buffers                | 'helm-occur                                                 |
| 34                | Occur       | Helm imenu                                                | 'helm-imenu                                                 |
| M-i               | Occur       | Helm swoop                                                | 'helm-swoop                                                 |
| M-I               | Occur       | Helm swoop back to last point                             | 'helm-swoop-back-to-last-point                              |
| ok                | Occur       | Projectile multiple occur                                 | 'projectile-multi-occur                                     |
| C-0               | Windows     | Select previous window                                    | (lambda () (interactive) (select-window (previous-window))) |
| C-9               | Windows     | Select next window                                        | (lambda () (interactive) (select-window (next-window)))     |
| <f2>              | Windows     | Split window vertically                                   | 'split-window-vertically                                    |
| <f3>              | Windows     | Split window horizontally                                 | 'split-window-horizontally                                  |
| <f4>              | Windows     | Delete current window (not the buffer)                    | 'delete-window                                              |
| <f5>              | Windows     | Only keep the current window and delete all others        | 'delete-other-windows                                       |
| <f7>              | Windows     | Toggle arrangement of two windows horizontally/vertically | 'toggle-window-split                                        |
| <M-up>            | Windows     | Move the current buffer window up                         | 'buf-move-up                                                |
| <M-down>          | Windows     | Move the current buffer window down                       | 'buf-move-down                                              |
| <M-left>          | Windows     | Move the current buffer window left                       | 'buf-move-left                                              |
| <M-right>         | Windows     | Move the current buffer window right                      | 'buf-move-right                                             |
| vg                | Find/Grep   | VC git grep                                               | 'vc-git-grep                                                |
| C-h C-f           | Find/Grep   | Grep find                                                 | 'grep-find                                                  |
| C-h C-o           | Find/Grep   | list matching regexp                                      | 'occur                                                      |
| C-h C-g           | Find/Grep   | Use the ag cli tool to grep project                       | 'ag-project                                                 |
| C-h C-l           | Find/Grep   | Helm locate                                               | 'helm-locate                                                |
| C-h C-z           | Find/Grep   | Projectile find file                                      | 'projectile-find-file                                       |
| C-h g             | Find/Grep   | Projectile grep                                           | 'projectile-grep                                            |
| C-h z             | Find/Grep   | Projectile ack                                            | 'projectile-ack                                             |
| M-0               | Find/Grep   | Helm find files with Git                                  | 'helm-git-find-files                                        |
| C-c g             | VCS         | Magit status - manual: http://magit.github.io/magit/      | 'magit-status                                               |
| C-c l             | VCS         | Magit log                                                 | 'magit-log                                                  |
| bm                | VCS         | Magit blame mode                                          | 'magit-blame-mode                                           |
| C-c s             | Open        | Open emacs shell                                          | 'shell                                                      |
| C-h r             | Open        | Open/hide dedicated term                                  | 'multi-term-dedicated-toggle                                |
| C-h C-c           | Open        | Next multi-term buffer                                    | 'multi-term-next                                            |
| C-h C-r           | Open        | Previous multi-term buffer                                | 'multi-term-prev                                            |
| C-h n             | Open        | New multi-term buffer                                     | 'multi-term                                                 |
| C-c c             | Open        | Open deft (quick notes tool)                              | 'deft                                                       |
| nm                | Open        | Open mu4e                                                 | 'mu4e                                                       |
| C-c e             | Open        | Open/connect with  ERC                                    | 'my-erc-connect                                             |
| C-h C-m           | Open        | Popup discover-my-major window                            | 'discover-my-major                                          |
| C-h C-<return>    | Open        | Emacs Web Wowser (internal Webbrowser)                    | 'eww                                                        |
| C-h M-RET         | Open        | Emacs Web Wowser do what I mean                           | 'my-eww-browse-dwim                                         |
| C-h C--           | Open        | Helm: Google                                              | 'helm-google                                                |
| C-h o             | Org         | Helm: Org info manual                                     | 'helm-info-org                                              |
| C-h C-n           | Org         | Open Org mode agenda                                      | (lambda () (interactive) (org-agenda nil "n"))              |
| C-h t             | Org         | Cpture simple task (todo)                                 | (lambda () (interactive) (org-capture nil "s"))             |
| C-h T             | Org         | Capture selection (todo)                                  | 'org-capture                                                |
| C-c i             | Org         | Start the clock on the current item                       | 'org-clock-in                                               |
| C-c o             | Org         | Stop the clock on the current item                        | 'org-clock-out                                              |
| C-c C-9           | Org         | Insert a new subheading and demote it                     | 'org-insert-subheading                                      |
| C-c C-0           | Org         | Insert a new TODO subheading                              | 'org-insert-todo-subheading                                 |
| C-h C-.           | Org         | Open/switch to home.org                                   | (lambda () (interactive) (find-file "~/org/home.org"))      |
| C-h C-u           | Org         | Open/switch to work.org                                   | (lambda () (interactive) (find-file "~/org/work.org"))      |
| C-h C-w           | Org         | Cut the current subtree into the clipboard                | 'org-cut-subtree                                            |
| M-;               | Evil        | Comment/Uncomment line                                    | 'evilnc-comment-or-uncomment-lines                          |
| C-c l             | Evil        | Comment/Uncomment to the line                             | 'evilnc-comment-or-uncomment-to-the-line                    |
| C-c c             | Evil        | Copy and Comment lines                                    | 'evilnc-copy-and-comment-lines                              |
| C-c p             | Evil        | Comment/Uncomment paragraphs                              | 'evilnc-comment-or-uncomment-paragraphs                     |
| ESC               | Global      | Replace Ctl-g                                             | 'keyboard-escape-quit                                       |
| <C-M-h>           | Smartparens | Forward Sexp                                              | 'sp-forward-sexp                                            |
| <C-M-l>           | Smartparens | Backward Sexp                                             | 'sp-backward-sexp                                           |
| <C-M-j>           | Smartparens | Down Sexp                                                 | 'sp-down-sexp                                               |
| <C-M-k>           | Smartparens | Up Sexp                                                   | 'sp-up-sexp                                                 |
| <C-M-a>           | Smartparens | Backward Down Sexp                                        | 'sp-backward-down-sexp                                      |
| <C-M-u>           | Smartparens | Backward Up Sexp                                          | 'sp-backward-up-sexp                                        |
| <C-M-n>           | Smartparens | Next Sexp                                                 | 'sp-next-sexp                                               |
| <C-M-p>           | Smartparens | Previous Sexp                                             | 'sp-previous-sexp                                           |
| <C-M-k>           | Smartparens | Kill Sexp                                                 | 'sp-kill-sexp                                               |
| <M-delete>        | Smartparens | Unwrap Sexp                                               | 'sp-unwrap-sexp                                             |
| <M-backspace>     | Smartparens | Backward Unwrap Sexp                                      | 'sp-backward-unwrap-sexp                                    |
| C-S-<right>       | Smartparens | Forward Slurp Sexp                                        | 'sp-forward-slurp-sexp                                      |
| C-S-<left>        | Smartparens | Forward Barf Sexp                                         | 'sp-forward-barf-sexp                                       |
| <C-M-left>        | Smartparens | Backward Slurp Sexp                                       | 'sp-backward-slurp-sexp                                     |
| <C-M-right>       | Smartparens | Backward Barf Sexp                                        | 'sp-backward-barf-sexp                                      |
| <C-M-D>           | Smartparens | Slice Sexp                                                | 'sp-slice-sexp                                              |


**** Evil Key definition table                                     :noexport:
     #+TBLNAME: evil_keys
     | Combo      | Category            | Desciption                           | Command                                 |
     | ;          | Evil Prefixes       | <Leader> key for further keybindings |                                         |
     | <Leader>jc | Evil Ace            | Jump Char                            | 'evil-ace-jump-char-mode                 |
     | <Leader>jw | Evil Ace            | Jump Word                            | 'evil-ace-jump-word-mode                 |
     | <Leader>jl | Evil Ace            | Jump Line                            | 'evil-ace-jump-line-mode                 |
     | <Leader>ci | Evil Nerd Commenter | Comment/Uncomment to the line        | 'evilnc-comment-or-uncomment-to-the-line |
     | <Leader>cl | Evil Nerd Commenter | Copy and Comment lines               | 'evilnc-copy-and-comment-lines           |
     | <Leader>cp | Evil Nerd Commenter | Comment/Uncomment paragraphs         | 'evilnc-comment-or-uncomment-paragraphs  |
     | <Leader>cr | Evil Nerd Commenter | Comment/Uncomment region             | 'evilnc-comment-or-uncomment-region      |

     Keybinding which are provided by corresponding plugins can be found in their documentation

     [[https://github.com/Dewdrops/evil-extra-operator]]
     [[https://github.com/tarao/evil-plugins]]
     [[https://github.com/redguardtoo/evil-nerd-commenter]]
     [[https://github.com/redguardtoo/evil-matchit]]
     [[https://github.com/Dewdrops/evil-exchange]]
     [[https://github.com/timcharper/evil-surround]]
     [[https://github.com/Dewdrops/evil-extra-operator]]

** Theme, Faces, Frame

   Here goes everything theme-related.

*** Pre-theme

    First things first - resetting theme to default on any load-theme will fix all small problems during theme change

#+begin_src emacs-lisp
(defadvice load-theme
  (before theme-dont-propagate activate)
  (mapcar #'disable-theme custom-enabled-themes))
#+end_src

Treat all themes as safe - don't see a real reason not too.

#+begin_src emacs-lisp
(setq custom-safe-themes t)
#+end_src

*** Set theme, face, frame

I really like solariazed and themes from [[https://github.com/owainlewis/emacs-color-themes/][Emacs Color Themes]]

Here's a preview from two of my favorite ones:

#+CAPTION: Hickey
#+NAME: Hickey theme
https://raw.github.com/owainlewis/emacs-color-themes/master/previews/hickey.png

#+CAPTION: Odersky
#+NAME: Hickey theme
https://raw.github.com/owainlewis/emacs-color-themes/master/previews/odersky.png

Also, for those who don't want to shell out for PragmataPro, the free [[http://mplus-fonts.sourceforge.jp/mplus-outline-fonts/download/index-en.html][M+ font]] is a tough one to beat.
They both are abolutely amazing each in it's own way.

#+begin_src emacs-lisp
(load-theme 'solarized-light t)
#+end_src

Select the first available font in order of preference

#+begin_src emacs-lisp
(require 'dash)
(defun font-candidate (&rest fonts)
  "Return the first available font."
  (--first (find-font (font-spec :name it)) fonts))

(set-face-attribute 'default nil :font (font-candidate
                                        "M+ 2m:pixelsize=16:weight=light:slant=normal:width=normal:spacing=100:scalable=true"
                                        "PragmataPro-16:weight=normal"
                                        "Menlo-16:weight=normal"
                                        "DejaVu Sans Mono-10:weight=normal"))
#+end_src

Put that line into =~/.user.el= which is loaded [[*User%20Settings][in this init file too.]]

#+begin_src emacs-lisp
(setq frame-title-format
      '((:eval (if (buffer-file-name)
                   (abbreviate-file-name (buffer-file-name))
                 "%b"))))
#+end_src

For the frame title either show a file or a buffer name (if the buffer isn't visiting a file).

*** Post-theme tweaks
Some themes don't cover faces for the plugins I use. Here I tweak them

Git gutter backgroung is not set correctly by many themes.
This will reset it to the default background

#+begin_src emacs-lisp
(when (require 'git-gutter nil 'noerror)
  (set-face-background 'git-gutter:unchanged nil))
#+end_src

This one is for fast switching
#+begin_src emacs-lisp :tangle yes
(defun theme-dark()
  (interactive)
  (progn
    (load-theme 'odersky t)
    (set-face-attribute 'default nil :font (font-candidate "M+ 2m:pixelsize=16:weight=light:slant=normal:width=normal:spacing=100:scalable=true" "PragmataPro-16:weight=normal" "Menlo-16:weight=normal" "DejaVu Sans Mono-10:weight=normal"))))
#+end_src

** Custom Functions
*** my-url-insert-file-contents

#+begin_src emacs-lisp
(defun my-url-insert-file-contents (url)
  "Prompt for URL and insert file contents at point."
  (interactive "sURL: ")
  (url-insert-file-contents url)
  )
#+end_src

*** my-find-function-or-variable-at-point

#+begin_src emacs-lisp
(defun my-find-function-or-variable-at-point ()
  "Find directly the function/variable at point in the other window."
  (interactive)
  (let ((var (variable-at-point))
        (func (function-called-at-point)))
    (cond
     ((not (eq var 0)) (find-variable-other-window var))
      (func (find-function-other-window func))
       (t (message "Neither function nor variable found!")))))
#+end_src

I don't care if is a function or a variable... just go there, Emacs!

*** show-file-name

#+begin_src emacs-lisp
(defun show-file-name ()
  "Show the full path file name in the minibuffer."
  (interactive)
  (message (buffer-file-name))
  (kill-new (file-truename buffer-file-name))
  )
#+end_src

Display, the copy the filename of current buffer to kill ring.

*** my/split-window

#+begin_src emacs-lisp
(defun my/split-window()
  "Split the window to see the most recent buffer in the other window.
Call a second time to restore the original window configuration."
  (interactive)
  (if (eq last-command 'my/split-window)
      (progn
        (jump-to-register :my/split-window)
        (setq this-command 'my/unsplit-window))
    (window-configuration-to-register :my/split-window)
    (switch-to-buffer-other-window nil)))
#+end_src

*** toggle-window-split

#+begin_src emacs-lisp
(defun toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
         (next-win-buffer (window-buffer (next-window)))
         (this-win-edges (window-edges (selected-window)))
         (next-win-edges (window-edges (next-window)))
         (this-win-2nd (not (and (<= (car this-win-edges)
                     (car next-win-edges))
                     (<= (cadr this-win-edges)
                     (cadr next-win-edges)))))
         (splitter
          (if (= (car this-win-edges)
             (car (window-edges (next-window))))
          'split-window-horizontally
        'split-window-vertically)))
    (delete-other-windows)
    (let ((first-win (selected-window)))
      (funcall splitter)
      (if this-win-2nd (other-window 1))
      (set-window-buffer (selected-window) this-win-buffer)
      (set-window-buffer (next-window) next-win-buffer)
      (select-window first-win)
      (if this-win-2nd (other-window 1))))))
#+end_src

*** my-open-terminal
TODO Fix to work with iTerm on MAC
#+begin_src emacs-lisp
(defvar my-terminal '("terminator" . "--working-directory=")
  "Terminal executable and after the dot the working directory option for the terminal"
  )

(defun my-open-terminal (project-root-p)
  "Open the terminal emulator either from the project root or
  from the location of the current file."
  (start-process "*my-terminal*" nil (car my-terminal)
   (concat (cdr my-terminal)
           (file-truename
            (if project-root-p (projectile-project-root)
              (file-name-directory (or dired-directory load-file-name buffer-file-name)))
    ))
   )
  )
#+end_src

*** my-isearch-goto-match-beginning

#+begin_src emacs-lisp
(defun my-isearch-goto-match-beginning ()
  (when (and isearch-forward (not isearch-mode-end-hook-quit)) (goto-char isearch-other-end)))
(add-hook 'isearch-mode-end-hook 'my-isearch-goto-match-beginning)
#+end_src

Make =isearch-forward= put the cursor at the start of the search, not the end, so that isearch can be used for navigation. See also http://www.emacswiki.org/emacs/IsearchOtherEnd.

*** my-indent-whole-buffer

#+begin_src emacs-lisp
(defun my-indent-whole-buffer ()
  (interactive)
  (indent-region (point-min) (point-max)))
#+end_src

*** my-show-help

#+begin_src emacs-lisp
(require 'pos-tip)
(defun my-show-help (doc-function)
  "Show docs for symbol at point or at beginning of list if not on a symbol.
Pass symbol-name to the function DOC-FUNCTION."
  (interactive)
  (let ((s (symbol-name
            (save-excursion
              (or (symbol-at-point)
                  (progn (backward-up-list)
                         (forward-char)
                         (symbol-at-point)))))))
    (let ((doc-string (funcall doc-function s)))
      (when doc-string
          (pos-tip-show doc-string 'popup-tip-face (point) nil -1 60))
        (message "No documentation for %s" s)
        )))
(define-key lisp-mode-shared-map (kbd "C-c C-d")
  (lambda ()
    (interactive)
    (my-show-help #'ac-symbol-documentation)))
#+end_src

I wanted to be able to get a documentation popup without having to trigger auto-complete. It's mostly stolen from [[http://jaderholm.com/][Scott Jaderholm]] (the code is on [[http://www.emacswiki.org/emacs/AutoComplete][Emacswiki]]), but has been made more general to also work with other completion functions.

*** omnicompletion-like-vim

Activate all words omnicompletion like in vim
particularly handy for text files, todo lists. However not always
useful since it sucks in code where it mixes up syntax with comments
so we have a dedicated functino that enables it

#+begin_src emacs-lisp :tangle yes
(defun omnicompletion-like-vim ()
  (interactive)
  (require 'dabbrev)
  (require 'ac-dabbrev)
  (auto-complete-mode))
#+end_src

*** kill-other-buffers

#+begin_src emacs-lisp :tangle yes
;; Kill all buffers except for the current one
(defun kill-other-buffers ()
    "Kill all other buffers."
    (interactive)
    (mapc 'kill-buffer
          (delq (current-buffer)
                (remove-if-not 'buffer-file-name (buffer-list)))))
#+end_src

** Global hooks and advices

#+begin_src emacs-lisp
;; slick-copy: make copy-past a bit more intelligent
;; from: http://www.emacswiki.org/emacs/SlickCopy
(defadvice kill-ring-save (before slick-copy activate compile)
  "When called interactively with no active region, copy a single
line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (message "Copied line")
     (list (line-beginning-position)
           (line-beginning-position 2)))))
#+end_src
#+begin_src emacs-lisp

(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no active region, kill a single
line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (list (line-beginning-position)
           (line-beginning-position 2)))))
#+end_src
#+begin_src emacs-lisp

;; bury *scratch* buffer instead of kill it
(defadvice kill-buffer (around kill-buffer-around-advice activate)
  (let ((buffer-to-kill (ad-get-arg 0)))
    (if (equal buffer-to-kill "*scratch*")
        (bury-buffer)
      ad-do-it)))
#+end_src
#+begin_src emacs-lisp

;; Make terminal support Unicode - should have worked, but doesnt' yet
(defadvice ansi-term (after advise-ansi-term-coding-system)
  (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))
(ad-activate 'ansi-term)

(add-hook 'term-exec-hook
          (function
           (lambda ()
             (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))))
#+end_src
#+begin_src emacs-lisp

;;remove all trailing whitespace and trailing blank lines before
;;saving the file
(defun cleanup-whitespace-on-save ()
  (let ((whitespace-style '(trailing empty)) )
    (whitespace-cleanup)))

(add-hook 'before-save-hook 'cleanup-whitespace-on-save)
#+end_src

** Modes
*** Disabled modes - those I'm not yet sure about
**** auto-dim-other-buffers
#+BEGIN_QUOTE
Visually makes non-current buffers less prominent. Currently disabled, but original author liked it.
#+END_QUOTE

Github: https://github.com/mina86/auto-dim-other-buffers.el

#+begin_src emacs-lisp
(auto-dim-other-buffers-mode -1)
#+end_src
*** Modes that change interface and behavior
**** melpa-upstream-visit

Adds a button to the package info page to visit the repository homepage.

#+begin_src emacs-lisp
(require 'melpa-upstream-visit)
#+end_src

**** auto-compile

#+begin_src emacs-lisp
(require 'auto-compile)

(auto-compile-on-load-mode 1)
(auto-compile-on-save-mode 1)
#+end_src

**** uniqify

#+BEGIN_QUOTE
Unique buffer names dependent on file name
#+END_QUOTE

#+begin_src emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
(setq uniquify-separator "/")
(setq uniquify-after-kill-buffer-p t)
(setq uniquify-ignore-buffers-re "^\\*")
#+end_src
**** recentf

#+BEGIN_QUOTE
This package maintains a menu for visiting files that were operated on recently.  When enabled a new "Open Recent" sub menu is displayed in the "File" menu.  The recent files list is automatically saved across Emacs sessions.  You can customize the number of recent files displayed, the location of the menu and others options (see the source code for details).
#+END_QUOTE

#+begin_src emacs-lisp
(when (require 'recentf nil t)
  (setq recentf-save-file (expand-file-name (concat conf-tmp-dir "/recentf")))
  (setq recentf-max-saved-items 200)
  (setq recentf-auto-save-timer
        (run-with-idle-timer 30 t 'recentf-save-list))
  (recentf-mode 1)

  (defun recentf-ido-find-file ()
    "Find a recent file using Ido."
    (interactive)
    (let ((file (ido-completing-read "Recent files: " recentf-list nil t)))
      (when file
        (find-file file))))

  (defun recentf-grizzl-find-file ()
    "Find a recent file using Grizzl."
    (interactive)
    (let ((file (completing-read "Recent files: " recentf-list nil t)))
      (when file
        (find-file file))))


  (defsubst file-was-visible-p (file)
    "Return non-nil if FILE's buffer exists and has been displayed."
    (let ((buf (find-buffer-visiting file)))
      (if buf
          (let ((display-count (buffer-local-value 'buffer-display-count buf)))
            (if (> display-count 0) display-count nil)))))

  (defsubst keep-default-and-visible-recentf-p (file)
    "Return non-nil if recentf would, by default, keep FILE, and
FILE has been displayed."
    (if (recentf-keep-default-predicate file)
        (file-was-visible-p file)))

  ;; When a buffer is closed, remove the associated file from the recentf
  ;; list if (1) recentf would have, by default, removed the file, or
  ;; (2) the buffer was never displayed.  This is useful because, for
  ;; example, CEDET opens a lot of files in the background to generate
  ;; its tags database, etc.
  (setq recentf-keep '(keep-default-and-visible-recentf-p))

  (recentf-mode 1)

  ;; I don't understand why, but it seems I need to load the list manually, after changing save-file
  (recentf-load-list))
#+end_src

Using recentf mode we can implement command to undo last killed buffer

#+begin_src emacs-lisp
(defun undo-kill-buffer (arg)
  "Re-open the last buffer killed.  With ARG, re-open the nth buffer."
  (interactive "p")
  (let ((recently-killed-list (copy-sequence recentf-list))
        (buffer-files-list
         (delq nil (mapcar (lambda (buf)
                             (when (buffer-file-name buf)
                               (expand-file-name (buffer-file-name buf)))) (buffer-list)))))
    (mapc
     (lambda (buf-file)
       (setq recently-killed-list
             (delq buf-file recently-killed-list)))
     buffer-files-list)
    (find-file
     (if arg (nth arg recently-killed-list)
       (car recently-killed-list)))))

#+end_src

**** saveplace

#+BEGIN_QUOTE
Automatically save place in each file. This means when you visit a file, point goes to the last place
where it was when you previously visited the same file.
#+END_QUOTE

#+begin_src emacs-lisp
(setq-default save-place t)
(setq save-place-file (concat conf-tmp-dir "places"))
(require 'saveplace)
#+end_src

I find this quite practical...
**** savehist

#+BEGIN_QUOTE
Many editors (e.g. Vim) have the feature of saving minibuffer history to an external file after exit.  This package provides the same feature in Emacs. When set up, it saves recorded minibuffer histories to a file.
#+END_QUOTE

#+begin_src emacs-lisp
(savehist-mode t)
(setq savehist-additional-variables
      ;; search entries
      '(search ring regexp-search-ring extended-command-history global-mark-ring mark-ring)
      ;; save every minute
      savehist-autosave-interval 60
      ;; keep the home clean
      savehist-file (concat conf-tmp-dir "savehist"))

#+end_src

I'm adding a few variables like the =extended-command-history= that I would like to persist too.

**** winner

Enable winner mode for C-c-(<left>|<right>) to navigate the history of buffer changes i.e. undo a split screen

#+begin_src emacs-lisp
(when (fboundp 'winner-mode)
      (winner-mode 1))
#+end_src

**** cua-mode

Enable cua-mode for rectangular selections

#+begin_src emacs-lisp
(require 'cua-base)
(require 'cua-gmrk)
(require 'cua-rect)
(cua-mode 1)
(setq cua-enable-cua-keys nil)
#+end_src

**** ibuffer

Use ibuffer integrated with ibuffer-vc.

#+begin_src emacs-lisp
(require 'ibuffer-vc)

(add-hook 'ibuffer-hook
          (lambda ()
            (ibuffer-vc-set-filter-groups-by-vc-root)
            (unless (eq ibuffer-sorting-mode 'alphabetic)
              (ibuffer-do-sort-by-alphabetic))))

(setq ibuffer-formats
      '((mark modified read-only vc-status-mini " "
              (name 18 18 :left :elide)
              " "
              (size 9 -1 :right)
              " "
              (mode 16 16 :left :elide)
              " "
              (vc-status 16 16 :left)
              " "
              filename-and-process)))

;; Switching to ibuffer puts the cursor on the most recent buffer
(defadvice ibuffer (around ibuffer-point-to-most-recent) ()
    "Open ibuffer with cursor pointed to most recent buffer name"
    (let ((recent-buffer-name (buffer-name)))
      ad-do-it
      (ibuffer-jump-to-buffer recent-buffer-name)))
  (ad-activate 'ibuffer)
#+end_src

**** auto-save-buffers-enhanced

Default autosave sucks. This one is much better

#+begin_src emacs-lisp :tangle no
(require 'auto-save-buffers-enhanced)
(auto-save-buffers-enhanced-include-only-checkout-path t)
(auto-save-buffers-enhanced t)
(setq auto-save-buffers-enhanced-interval 1.5)
(setq auto-save-buffers-enhanced-quiet-save-p t)
#+end_src
**** back-button

#+BEGIN_QUOTE
Back-button provides an alternative method for navigation by analogy with the "back" button in a web browser.

Every Emacs command which pushes the mark leaves behind an invisible record of the location of the point at that moment. Back-button moves the point back and forth over all the positions where some command pushed the mark.
Visual navigation through mark rings in Emacs.
#+END_QUOTE

#+CAPTION: back-button
#+NAME: fig:bb
https://raw.github.com/rolandwalker/back-button/master/back_button_example.png

=back-button= is written by Roland Walker. For more information see the [[https://github.com/rolandwalker/back-button][Github page]].

#+begin_src emacs-lisp
(setq back-button-local-keystrokes nil) ;don't overwrite C-x SPC binding
(require 'back-button)
(back-button-mode 1)
#+end_src
**** diff-hl

#+BEGIN_QUOTE
diff-hl-mode highlights uncommitted changes on the left side of the window, allows you to jump between and revert them selectively.
I'm not sure if it's better than git-gutter, but I'll sitk to it for now.

#+END_QUOTE

Github: https://github.com/dgutov/diff-hl

#+begin_src emacs-lisp
(global-diff-hl-mode)
(diff-hl-margin-mode)

(defun my-diff-hl-update ()
  (with-current-buffer (current-buffer) (diff-hl-update)))

(add-hook 'magit-refresh-file-buffer-hook 'my-diff-hl-update)
#+end_src

Turn on the global mode and use the margin (not the fringe) to show the diff. Run =diff-hl-update= via =magit-refresh-file-buffer-hook= (which is run for each buffer after a commit).

**** dired and dired+

#+BEGIN_QUOTE
Dired makes an Emacs buffer containing a listing of a directory, and
optionally some of its subdirectories as well.  You can use the normal
Emacs commands to move around in this buffer, and special Dired commands
to operate on the listed files.
#+END_QUOTE

Dired is nice way to browse the directory tree. I have added =dired+= which

#+BEGIN_QUOTE
extends functionalities provided by standard GNU Emacs libraries dired.el, dired-aux.el, and dired-x.el. The standard functions are all available, plus many more.
#+END_QUOTE

See the [[http://www.emacswiki.org/emacs/DiredPlus][EmacsWiki]] for detailed information on =dired+=.

Being in a dired buffer it is possible to make the buffer writable and thus rename files and permissions by editing the buffer. Use =C-x C-q= which runs the command =dired-toggle-read-only= to make that possible.

I often use =dired-jump= (mapped to =C-h C-d=) which jumps to Dired buffer corresponding to current buffer.

#+begin_src emacs-lisp
(setq dired-auto-revert-buffer t)
(toggle-diredp-find-file-reuse-dir 1)
(setq diredp-hide-details-initially-flag nil)
(setq diredp-hide-details-propagate-flag nil)
#+end_src

It seems that both flags are necessary to make dired+ not hide the details. =toggle-diredp-find-file-reuse-dir= will make sure that there is only one buffer kept around for =dired=. Normally =dired= creates a buffer for every opened directory.

**** ack-and-a-half + ag

I use both Ack and Ag sometimes, they are similar though ag is written in C and is considerably faster

#+begin_src emacs-lisp

;; Ack and a half
(defalias 'ack 'ack-and-a-half)
(defalias 'ack-same 'ack-and-a-half-same)
(defalias 'ack-find-file 'ack-and-a-half-find-file)
(defalias 'ack-find-file-same 'ack-and-a-half-find-file-same)

;; ag
(setq ag-highlight-search t)
#+end_src

**** ido-mode

#+BEGIN_EXAMPLE
Interactively do things with buffers and files
#+END_EXAMPLE

Great mode to quickly select buffers/files etc. Is built into Emacs since v22.

Select the previous match with =C-r= and next match with =C-s=.
To open =dired= at the current location press =C-d=.
Make a directory with =M-m=.

Use =C-j= if you want to create a file with what you have entered (and not the match).

I also prefer flx-ido mode - flex matching simply kicks ass and ido-vertical.

Github: https://github.com/lewang/flx

#+begin_src emacs-lisp
(setq ido-enable-flex-matching t
      ido-auto-merge-work-directories-length -1
      ido-create-new-buffer 'always
      ido-everywhere t
      ido-default-buffer-method 'selected-window
      ido-max-prospects 32
      ido-ignore-extensions t
      ido-use-filename-at-point 'guess
      )
(ido-mode 1)
(flx-ido-mode 1)
(ido-vertical-mode 1)
(setq ido-vertical-define-keys 'C-n-C-p-up-down-left-right)
(setq ido-use-faces nil)
(icomplete-mode 1)

;; Ignore .DS_Store files with ido mode
(add-to-list 'ido-ignore-files "\\.DS_Store")
#+end_src

I prefer the list of files to be sorted by mtime (like 'ls -ltr'), instead of alphabetically. Let's make it happen.

#+begin_src emacs-lisp
;; sort ido filelist by mtime instead of alphabetically
(add-hook 'ido-make-file-list-hook 'ido-sort-mtime)
(add-hook 'ido-make-dir-list-hook 'ido-sort-mtime)
(defun ido-sort-mtime ()
  (setq ido-temp-list
        (sort ido-temp-list
              (lambda (a b)
                (let ((a-tramp-file-p (string-match-p ":\\'" a))
                      (b-tramp-file-p (string-match-p ":\\'" b)))
                  (cond
                   ((and a-tramp-file-p b-tramp-file-p)
                    (string< a b))
                   (a-tramp-file-p nil)
                   (b-tramp-file-p t)
                   (t (time-less-p
                       (sixth (file-attributes (concat ido-current-directory b)))
                       (sixth (file-attributes (concat ido-current-directory a))))))))))
  (ido-to-end  ;; move . files to end (again)
   (delq nil (mapcar
              (lambda (x) (and (char-equal (string-to-char x) ?.) x))
              ido-temp-list))))
#+end_src

We can use IDO to complete anything. [[http://www.emacswiki.org/emacs/InteractivelyDoThings#toc15][From emacswiki]].

#+begin_src emacs-lisp
(defvar ido-enable-replace-completing-read t
  "If t, use ido-completing-read instead of completing-read if possible.

    Set it to nil using let in around-advice for functions where the
    original completing-read is required.  For example, if a function
    foo absolutely must use the original completing-read, define some
    advice like this:

    (defadvice foo (around original-completing-read-only activate)
      (let (ido-enable-replace-completing-read) ad-do-it))")

;; Replace completing-read wherever possible, unless directed otherwise
(defadvice completing-read
    (around use-ido-when-possible activate)
  (if (or (not ido-enable-replace-completing-read) ; Manual override disable ido
          (and (boundp 'ido-cur-list)
               ido-cur-list)) ; Avoid infinite loop from ido calling this
      ad-do-it
    (let ((allcomp (all-completions "" collection predicate)))
      (if allcomp
          (setq ad-return-value
                (ido-completing-read prompt
                                     allcomp
                                     nil require-match initial-input hist def))
        ad-do-it))))
#+end_src

**** smex

Smex is an IDO for command-list. I prefer IDO over Helm, for the simple reason that helm doesn't do flex matching

#+begin_src emacs-lisp
(require 'smex)
(smex-initialize)
#+end_src

**** popwin

#+begin_src emacs-lisp
(require 'popwin)
(setq display-buffer-function 'popwin:display-buffer)

(setq popwin:special-display-config
      '(("*Help*"  :height 30)
        ("*Completions*" :noselect t)
        ("*Messages*" :noselect t :height 30)
        ("*Apropos*" :noselect t :height 30)
        ("*compilation*" :noselect t)
        ("*Backtrace*" :height 30)
        ("*Messages*" :height 30)
        ("*Occur*" :noselect t)
        ("*undo-tree*" :noselect t)
        ("*Ibuff\\*" :regexp t :noselect t :stick t)
        ("*Org\\*" :regexp t :noselect t)
        ("*Ido Completions*" :noselect t :height 30)
        ("*magit-commit*" :noselect t :height 40 :width 80 :stick t)
        ("*magit-diff*" :noselect t :height 40 :width 80)
        ("*magit-edit-log*" :noselect t :height 15 :width 80)
        ("\\*ansi-term\\*.*" :regexp t :height 30)
        ("*shell*" :height 30)
        (".*overtone.log" :regexp t :height 30)
        ("*gists*" :height 30)
        ("*sldb.*":regexp t :height 30)
        ("*nrepl-error*" :height 30 :stick t)
        ("*nrepl-doc*" :height 30 :stick t)
        ("*nrepl-src*" :height 30 :stick t)
        ("*nrepl-result*" :height 30 :stick t)
        ("*nrepl-macroexpansion*" :height 30 :stick t)
        ("*fixmee notices*" :height 30 :stick t)
        ("*Kill Ring*" :height 30)
        ("*Compile-Log*" :height 30 :stick t)
        ("*git-gutter:diff*" :height 30 :stick t)))
#+end_src
**** magit

Magit is the king of Git interaction for Emacs.

There's a short [[http://www.emacswiki.org/emacs/Magit#toc1][Crash Course on Emacswiki]]:

#+begin_src org
- M-x magit-status to see git status, and in the status buffer:
- s to stage files
- c to commit (type in your commit message then C-c C-c to save the message and commit)
- b b to switch to a branch

Other handy keys:

- P P to do a git push
- F F to do a git pull

try to press TAB
#+end_src

See the [[http://magit.github.io/magit/magit.html][Magit manual]] for more information.

#+begin_src emacs-lisp
;;(when (fboundp 'file-notify-add-watch)
 ;; (add-hook 'magit-status-mode-hook 'magit-filenotify-mode))
(setq magit-save-some-buffers nil) ;don't ask to save buffers
(setq magit-set-upstream-on-push t) ;ask to set upstream
(setq magit-diff-refine-hunk t) ;show word-based diff for current hunk
#+end_src

One of the annoying things about Emacs is that sometimes it's hard to return to the previous state, from some smartypants major mode. The following two lines fix this for magit buffers.
Both q and ESC should fully quit magit session. That's how I want it

#+begin_src emacs-lisp
(defun magit-mode-exit-keys ()
  (local-set-key (kbd "<escape>") 'magit-mode-quit-window)
  (local-set-key (kbd "<escape>") 'magit-mode-quit-window))
;; add to html-mode-hook
(add-hook 'magit-mode-hook 'magit-mode-exit-keys)
#+end_src

Committing should act like =git commit -a= by default.

When Emacs has been compiled with inotiy support...

#+begin_src shell-script
#./configure --with-file-notification=inotify
#+end_src

...the function =file-notify-add-watch= is bound and we add =magit-filenotify-mode= to the hook so that file updates get reflected automatically in magit status.

**** fasd

#+BEGIN_QUOTE
Fasd (pronounced similar to "fast") is a command-line productivity booster.
Fasd offers quick access to files and directories for POSIX shells. It is
inspired by tools like autojump
#+END_QUOTE

The command-line tool is available an Github: https://github.com/clvv/fasd

The =global-fasd-mode= was written by Steckerhalter. It's purpose is to make the quick access DB from =fasd= available in Emacs and also to add visited files and directories from Emacs to the =fasd= DB.

Github: https://github.com/steckerhalter/emacs-fasd

#+begin_src emacs-lisp
(global-fasd-mode 1)
#+end_src
**** fixmee
#+BEGIN_QUOTE
Fixmee-mode tracks fixme notices in code comments, highlights them, ranks them by urgency, and lets you navigate to them quickly.

A distinguishing feature of this library is that it tracks the urgency of each notice, allowing the user to jump directly to the most important problems.
#+END_QUOTE

=fixmee= was written by Roland Walker and lives on Github: https://github.com/rolandwalker/fixmee

#+begin_src emacs-lisp
(global-fixmee-mode 1)
#+end_src

I had tried similar modes like =fic-ext=mode= but fount them lacking a bit. Let's see how this one performs...

TODO: Seems not to work in org mode
**** smart-mode-line

#+BEGIN_QUOTE
Smart Mode Line is a sexy mode-line for Emacs, that aims to be easy to read from small to large monitors by using a prefix feature and smart truncation.
#+END_QUOTE

It is written by Artur Bruce-Connor. The default Emacs mode-line has some shortcomings and =sml= does a good job at improving it.

#+begin_src emacs-lisp
;; (setq sml/vc-mode-show-backend t)
;; (sml/setup)
;; (sml/apply-theme 'nil) ;; Use theme specified settings
;;(set-face-attribute 'sml/prefix nil :foreground "#dcf692")
;;(set-face-attribute 'sml/folder nil :foreground "#f09fff")
;;(set-face-attribute 'sml/filename nil :foreground "#f6df92")
;;(set-face-attribute 'sml/vc-edited nil :foreground "#ff5f87")
#+end_src

Show the encoding and add VC information to the mode-line. Respect the theme-colors and customize some of the =sml= colors.

**** helm

#+BEGIN_QUOTE
Helm is incremental completion and selection narrowing framework for Emacs. It will help steer you in the right direction when you're looking for stuff in Emacs (like buffers, files, etc).

Helm is a fork of anything.el originaly written by Tamas Patrovic and can be considered to be its successor. Helm sets out to clean up the legacy code in anything.el and provide a cleaner, leaner and more modular tool, that's not tied in the trap of backward compatibility.
#+END_QUOTE

The Helm source code can be found [[https://github.com/emacs-helm/helm][at Github]].

You might want to checkout the [[https://github.com/emacs-helm/helm/wiki][Helm Wiki]] for detailed instructions on how Helm works.

#+begin_src emacs-lisp
(require 'helm-config)
(setq helm-mode-handle-completion-in-region nil) ; don't use helm for `completion-at-point'
(helm-mode nil)
(helm-gtags-mode 1)
(helm-descbinds-mode)
(setq helm-idle-delay 0.1)
(setq helm-input-idle-delay 0.1)
(setq helm-buffer-max-length 50)
(setq helm-M-x-always-save-history t)
(setq helm-buffer-details-flag nil)
(add-to-list 'helm-completing-read-handlers-alist '(org-refile)) ; helm-mode does not do org-refile well
(add-to-list 'helm-completing-read-handlers-alist '(org-agenda-refile)) ; same goes for org-agenda-refile
(require 'helm-git)
#+end_src

I'm not using [[https://github.com/emacs-helm/helm/wiki#6-helm-find-files][Helm Find Files]] to browse files anymore. I tried using it but gave up after a while. I found it to be more cumbersome than [[*ido-mode][ido-mode]].

I use [[https://github.com/emacs-helm/helm-descbinds][Helm Descbinds]] (=C-h b=) to get a quick key bindings overview.

**** helm-swoop

=helm-swoop= is a great Helm powered buffer search/occur interface:

#+CAPTION: helm-swoop
#+NAME: fig:swoop
https://raw.github.com/ShingoFukuyama/helm-swoop/master/image/helm-swoop.gif

Github: https://github.com/ShingoFukuyama/helm-swoop

#+begin_src emacs-lisp
(define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
#+end_src

**** move-text

Allows to move the current line or region up/down

#+begin_src emacs-lisp
(require 'move-text)
#+end_src

**** multi-term

#+BEGIN_QUOTE
A package for creating and managing multiple terminal buffers in Emacs
#+END_QUOTE

The source code is on [[http://www.emacswiki.org/emacs//multi-term.el][EmacsWiki]]

#+begin_src emacs-lisp
(setq multi-term-dedicated-select-after-open-p t) ;select the buffer!

(defun my-term-toggle-char-line-mode ()
  "Toggle between `term-char-mode' and `term-line-mode'."
  (interactive)
  (when (equal major-mode 'term-mode)
    (if (term-in-line-mode)
        (term-char-mode)
      (term-line-mode))))

(defun my-term-setup ()
  (interactive)
  (define-key term-raw-map (kbd "C-y") 'term-send-raw)
  (define-key term-raw-map (kbd "C-p") 'term-send-raw)
  (define-key term-raw-map (kbd "C-n") 'term-send-raw)
  (define-key term-raw-map (kbd "C-s") 'term-send-raw)
  (define-key term-raw-map (kbd "C-r") 'term-send-raw)
  (define-key term-raw-map (kbd "M-p") (lambda () (interactive) (term-send-raw-string "\ep")))
  (define-key term-raw-map (kbd "M-n") (lambda () (interactive) (term-send-raw-string "\en")))
  (define-key term-raw-map (kbd "C-c y") 'term-paste)
  (define-key term-raw-map (kbd "C-c C-g") 'term-paste)
  (define-key term-raw-map (kbd "C-c C-r") 'my-term-toggle-char-line-mode)
  (define-key term-mode-map (kbd "C-c C-r") 'my-term-toggle-char-line-mode))
(add-hook 'term-mode-hook 'my-term-setup t)
#+end_src

I'd like to have the terminal respect the default keys of the shell as much as possible hence I remap the non-standard bindings to the defaults. Furthermore I want to switch between Emacs-style navigation (term-line-mode) and raw terminal input (term-char-mode) quickly.


TODO: Add region expand
TODO: Add multiple cursor
**** multiple-cursors

#+begin_quote
When you have an active region that spans multiple lines, the following will add a cursor to each line:

(global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)

When you want to add multiple cursors not based on continuous lines, but based on keywords in the buffer, use:

(global-set-key (kbd "C->") 'mc/mark-next-like-this)
(global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
(global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)

First mark the word, then add more cursors.
#+end_quote

#+begin_src emacs-lisp
(require 'multiple-cursors)
#+end_src

**** expand-region

#+begin_src emacs-lisp
(require 'expand-region)
#+end_src

**** rainbow-delimiters

I generally like rainbow-delimiters mode.

#+begin_src emacs-lisp :tangle yes
(global-rainbow-delimiters-mode)
#+end_src

*** Programming modes independent of languages

Like project management tools, parens management/coloring, completion frameworks, flycheck

**** prog-mode

Some defaults specific to programming modes

I hate visible whitespaces. They get cleaned out on save anyway, so what's the point of annoying me visually?

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook (lambda () (interactive) (setq show-trailing-whitespace nil)))
#+end_src

Show whitespace errors in all programming modes by turning on =show-trailing-whitespace= in these modes.

**** lisp-mode-shared-map

In all LISPS reindent with new line does wonders to readability

#+begin_src emacs-lisp :tangle yes
(define-key lisp-mode-shared-map (kbd "RET") 'reindent-then-newline-and-indent)
#+end_src

**** highlight-symbol

#+BEGIN_QUOTE
Automatic and manual symbol highlighting for Emacs
#+END_QUOTE

Highlights the word/symbol at point and any other occurrences in view. Also allows to jump to the next or previous occurrence.

#+begin_src emacs-lisp
(setq highlight-symbol-on-navigation-p t)
(add-hook 'prog-mode-hook 'highlight-symbol-mode)
#+end_src

**** grizzl

#+BEGIN_QUOTE
Grizzl is a small utility library to be used in other Elisp code needing fuzzy search behaviour. It is optimized for large data sets, using a special type of lookup table and supporting incremental searches (searches where the result can be narrowed-down by only searching what is already matched).
#+END_QUOTE

The source code for Grizzl can be found on [[https://github.com/d11wtq/grizzl][Github]]. It is written by Chris Corbyn who also wrote the PHP REPL =Boris=.

Grizzl is pretty cool, we can use it for more things.
Currently it is used by [[https://github.com/bbatsov/projectile][Projectile]] in my config. I quite like Grizzl. It offers some benefits for when entries are longer. For most cases =IDO= is better suited though.

#+begin_src emacs-lisp
(setq *grizzl-read-max-results* 30)
#+end_src

This is a wrapper around completing-read - to us it grizzl for more things. I disabled this code block for now, to play more with IDO-vertical

#+begin_src emacs-lisp :tangle no
(defun to-string (object)
  "Convert OBJECT to a string."
  (cond
   ((symbolp object) (symbol-name object))
   ((stringp object) object)
   ((numberp object) (number-to-string object))
   (t (prin1-to-string object))))

(defadvice completing-read (around grizzl-advise-completing-read activate)
  "Wrapper that uss grizzl"
  (let* ((completions (mapcar 'to-string
                              (all-completions "" collection predicate)))
         (search-index (grizzl-make-index completions)))
    (if search-index
        (setq ad-return-value
              (grizzl-completing-read prompt search-index))
      ad-do-it)))

(progn
  (ad-disable-advice 'completing-read 'around 'grizzl-advise-completing-read)
  (ad-activate 'completing-read))

(progn
  (ad-enable-advice 'completing-read 'around 'grizzl-advise-completing-read)
  (ad-activate 'completing-read))
#+end_src

I would like to see more than just the default results of 10.

**** projectile

#+BEGIN_QUOTE
Projectile is a project interaction library for Emacs. Its goal is to provide a nice set of features operating on a project level without introducing external dependencies(when feasible). For instance - finding project files has a portable implementation written in pure Emacs Lisp without the use of GNU find(but for performance sake an indexing mechanism backed by external commands exists as well).
#+END_QUOTE

Projectile is written by Bozhidar Batsov.

Github: https://github.com/bbatsov/projectile

#+begin_src emacs-lisp
(require 'projectile nil t)
(setq projectile-completion-system 'grizzl)
#+end_src

**** rainbow-mode

#+BEGIN_QUOTE
rainbow-mode is a minor mode for Emacs which displays strings representing colors with the color they represent as background.
#+END_QUOTE

Homepage: http://julien.danjou.info/projects/emacs-packages#rainbow-mode

#+begin_src emacs-lisp
(dolist (hook '(css-mode-hook
                html-mode-hook
                js-mode-hook
                emacs-lisp-mode-hook
                org-mode-hook
                text-mode-hook
                ))
  (add-hook hook 'rainbow-mode)
  )
#+end_src

**** smartparens

#+BEGIN_QUOTE
Smartparens is minor mode for Emacs that deals with parens pairs and tries to be smart about it. It started as a unification effort to combine functionality of several existing packages in a single, compatible and extensible way to deal with parentheses, delimiters, tags and the like.
#+END_QUOTE

Github: https://github.com/Fuco1/smartparens

#+begin_src emacs-lisp
(require 'smartparens-config)
;; "fix"" highlight issue in scratch buffer
(custom-set-faces '(sp-pair-overlay-face ((t ()))))

(smartparens-global-mode t)

;; highlights matching pairs
(show-smartparens-global-mode t)
#+end_src

**** vlf
#+BEGIN_QUOTE
Emacs minor mode that allows viewing, editing, searching and comparing large files in batches. Batch size can be adjusted on the fly and bounds the memory that is to be used for operations on the file. This way multiple large files can be instantly and simultaneously accessed without swapping and degraded performance.
#+END_QUOTE

Github: https://github.com/m00natic/vlfi

#+begin_src emacs-lisp
(setq vlf-application 'dont-ask)        ; just do it
(setq vlf-batch-size 8192)              ; a bit more text per batch please
(require 'vlf-integrate)                ; just do it for real
#+end_src
**** company
#+BEGIN_QUOTE
Company stands for "complete anything". It uses pluggable back-ends and front-ends to retrieve and display completion candidates.

It comes with several back-ends such as Elisp, Clang, Semantic, Eclim, Ropemacs, Ispell, dabbrev, etags, gtags, files, keywords and a few others.
#+END_QUOTE

#+CAPTION: company
#+NAME: fig:co
http://company-mode.github.io/images/company-semantic.png

#+begin_src emacs-lisp
(require 'company)
(setq company-idle-delay 0.3)
(setq company-tooltip-limit 20)
(setq company-minimum-prefix-length 2)
(setq company-echo-delay 0)
(setq company-auto-complete nil)
(global-company-mode 0)
(add-to-list 'company-backends 'company-dabbrev t)
(add-to-list 'company-backends 'company-ispell t)
(add-to-list 'company-backends 'company-files t)

(defun my-pcomplete-capf ()
  (add-hook 'completion-at-point-functions 'pcomplete-completions-at-point nil t))
(add-hook 'org-mode-hook #'my-pcomplete-capf)
#+end_src

Company for python - company-jedi

#+begin_src emacs-lisp
;;(add-hook 'python-mode-hook 'company-jedi-start)
#+end_src

**** flycheck-mode

- Automatic on-the-fly syntax checking while editing
- Fully automatic selection of the best syntax checker

Supports many languages:  AsciiDoc, C/C++, CFEngine, Chef cookbooks, CoffeeScript, CSS, D, Elixir, Emacs Lisp, Erlang, Go, Haml, Handlebars, Haskell, HTML, Javascript, JSON, LESS, Lua, Perl, PHP, Puppet, Python, Ruby, Rust, RST (ReStructuredText), Sass, Scala, SCSS, Slim, Shell scripts (POSIX Shell, Bash and Zsh), TeX/LaTeX, XML, YAML

Flycheck is written by [[http://lunaryorn.com/][Sebastian Wiesner]] a.ka =lunaryorn=.

Github: https://github.com/flycheck/flycheck

#+begin_src emacs-lisp
(global-flycheck-mode t) ;; Flycheck is smart not to be annoying, and works were it's supported
(setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc)) ;disable the annoying doc checker
(setq flycheck-indication-mode nil) ;Highlighting in line is enough for me
#+end_src

The modes where flycheck should be enabled.

**** iedit

#+begin_src emacs-lisp
(require 'iedit)
(setq iedit-unmatched-lines-invisible-default t)
#+end_src
**** hideshow

I like to see folding marks in fringe

#+begin_src emacs-lisp :tangle yes

(require 'hideshowvis)

(eval-after-load "hideshowvis"
  `(progn (load "hideshow-fringe" t)))

(autoload 'hideshowvis-enable "hideshowvis" "Highlight foldable regions")

(autoload 'hideshowvis-minor-mode "hideshowvis" "Will indicate regions foldable with hideshow in the fringe." 'interactive)

(add-hook 'prog-mode-hook 'hideshowvis-enable)
#+end_src

#+begin_src emacs-lisp :tangle yes
(require 'hideshow-org)
#+end_src

*** Clojure
**** cider

#+BEGIN_QUOTE
CIDER is Clojure IDE and REPL for Emacs, built on top of nREPL, the Clojure networked REPL server. It's a great alternative to the now deprecated combination of SLIME + swank-clojure.
#+END_QUOTE

It was formerly called =nrepl.el= and is written by Bozhidar Batsov.

Github: https://github.com/clojure-emacs/cider

#+begin_src emacs-lisp
(setq cider-popup-stacktraces nil)
#+end_src
**** nrepl-eval-sexp-fu

Flashes the evaluated expression (visual feedback)

#+begin_src emacs-lisp
(require 'nrepl-eval-sexp-fu)
(setq nrepl-eval-sexp-fu-flash-duration 0.4)
#+end_src
*** Common LISP
**** slime

#+BEGIN_QUOTE
SLIME, the Superior Lisp Interaction Mode for Emacs, is an Emacs mode for developing Common Lisp applications.
#+END_QUOTE

#+begin_src emacs-lisp
(when (file-exists-p "~/quicklisp/slime-helper.el") (load "~/quicklisp/slime-helper.el"))
#+end_src
*** TeX/LaTeX
**** auctex-mode

#+begin_src emacs-lisp
(setq TeX-PDF-mode t)
(setq TeX-parse-self t)
(setq TeX-auto-save t)
(setq TeX-save-query nil)

(add-hook 'doc-view-mode-hook 'auto-revert-mode)
(add-hook 'TeX-mode-hook
          '(lambda ()
             (define-key TeX-mode-map (kbd "<C-f8>")
               (lambda ()
                 (interactive)
                 (TeX-command-menu "LaTeX")))
             )
          )
#+end_src
*** Org mode
**** org-mode

#+BEGIN_QUOTE
Org mode is for keeping notes, maintaining TODO lists, planning projects, and authoring documents with a fast and effective plain-text system.
#+END_QUOTE

Org mode is the most amazing tool for Emacs. Even this Emacs configuration is written and annotated with it.

Homepage: http://orgmode.org/

***** General settings

#+begin_src emacs-lisp
(require 'org)
(add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))
(setq org-startup-folded t)
(setq org-startup-indented nil)
(setq org-startup-with-inline-images t)
(setq org-startup-truncated t)
(setq org-src-fontify-natively t)
(setq org-src-tab-acts-natively t)
(setq org-pretty-entities t) ;; Display UTF8- entities
(setq org-edit-src-content-indentation 0)
(setq org-confirm-babel-evaluate nil)
(setq org-use-speed-commands t)
(setq org-refile-targets '((org-agenda-files :maxlevel . 3)))
(setq org-refile-use-outline-path 'file)
(setq org-default-notes-file (concat org-directory "/notes.org"))
(add-to-list 'org-modules 'org-habit)
(setq org-habit-graph-column 60)

;; Don't use the same TODO state as the current heading for new heading
(defun my-org-insert-todo-heading () (interactive) (org-insert-todo-heading t))
(define-key org-mode-map (kbd "<M-S-return>") 'my-org-insert-todo-heading)
#+end_src

I'd like to use windmove in org mode too

#+begin_src emacs-lisp
;; windmove compatibility
(add-hook 'org-shiftup-final-hook 'windmove-up)
(add-hook 'org-shiftleft-final-hook 'windmove-left)
(add-hook 'org-shiftdown-final-hook 'windmove-down)
(add-hook 'org-shiftright-final-hook 'windmove-right)
#+end_src

Yasnippet integration

#+begin_src emacs-lisp
(add-hook 'org-mode-hook
          (lambda ()
            (org-set-local 'yas/trigger-key [tab])
            (define-key yas/keymap [tab] 'yas/next-field-or-maybe-expand)))

(defun yas/org-very-safe-expand ()
  (let ((yas/fallback-behavior 'return-nil)) (yas/expand)))

(add-hook 'org-mode-hook
          (lambda ()
            (make-variable-buffer-local 'yas/trigger-key)
            (setq yas/trigger-key [tab])
            (add-to-list 'org-tab-first-hook 'yas/org-very-safe-expand)
            (define-key yas/keymap [tab] 'yas/next-field)))

(add-hook 'org-mode-hook 'yas-minor-mode)
#+end_src


***** Agenda

#+begin_src emacs-lisp
;; create the file for the agendas if it doesn't exist
(let ((agendas "~/.agenda_files"))
  (unless (file-readable-p agendas)
    (with-temp-file agendas nil))
  (setq org-agenda-files agendas))

;; display the agenda first
(setq org-agenda-custom-commands
      '(("n" "Agenda and all TODO's"
        ((alltodo "")
         (agenda "")))))

;; (defun my-initial-buffer-choice ()
  ;; (org-agenda nil "n")
  ;; (delete-other-windows)
  ;; (current-buffer))
;; (setq initial-buffer-choice #'my-initial-buffer-choice)

(setq org-agenda-start-with-log-mode t)
(setq org-agenda-todo-ignore-scheduled 'future) ; don't show future scheduled
(setq org-agenda-todo-ignore-deadlines 'far)    ; show only near deadlines

(setq
 appt-message-warning-time 30
 appt-display-interval 15
 appt-display-mode-line t      ; show in the modeline
 appt-display-format 'window)
(appt-activate 1)              ; activate appt (appointment notification)

(org-agenda-to-appt)           ; add appointments on startup

;; add new appointments when saving the org buffer, use 'refresh argument to do it properly
(defun my-org-agenda-to-appt-refresh () (org-agenda-to-appt 'refresh))
(defun my-org-mode-hook ()
  (add-hook 'after-save-hook 'my-org-agenda-to-appt-refresh nil 'make-it-local))
(add-hook 'org-mode-hook 'my-org-mode-hook)

(require 'notifications)
(defun my-appt-disp-window-function (min-to-app new-time msg)
  (notifications-notify :title (format "Appointment in %s min" min-to-app) :body msg))
(setq appt-disp-window-function 'my-appt-disp-window-function)
(setq appt-delete-window-function (lambda (&rest args)))

;; add state to the sorting strategy of todo
(setcdr (assq 'todo org-agenda-sorting-strategy) '(todo-state-up priority-down category-keep))
#+end_src

***** Todo

#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence
         "TODO(t)"
         "WAITING(w)"
         "SCHEDULED(s)"
         "FUTURE(f)"
         "|"
         "DONE(d)"
         )))
(setq org-todo-keyword-faces
      '(
        ("SCHEDULED" . warning)
        ("WAITING" . font-lock-doc-face)
        ("FUTURE" . "white")
        ))
(setq org-log-into-drawer t) ; don't clutter files with state logs
#+end_src

***** Clocking

#+begin_src emacs-lisp
(setq org-clock-idle-time 15)
(setq org-clock-in-resume t)
(setq org-clock-persist t)
(org-clock-persistence-insinuate)
(setq org-clock-frame-title-format (append '((t org-mode-line-string)) '(" ") frame-title-format))
(setq org-clock-clocked-in-display 'both)
#+end_src

***** org-mode-blog

Load the project template for my blog

#+begin_src emacs-lisp
(let ((file (expand-file-name "elisp/org-mode-blog-setup.el" "~/org-mode-blog")))
  (when (file-exists-p file)
    (load file t t t)))
#+end_src

Don't forget to set =org-mode-blog-publishing-directory= to the desired export location in =~/.user.el=.

**** conf-mode

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.tks\\'" . org-mode))
#+end_src

**** deft
#+begin_src emacs-lisp
(setq
 deft-extension "org"
 deft-directory "~/deft"
 deft-text-mode 'org-mode
 deft-use-filename-as-title t
 deft-auto-save-interval 20
 )
#+end_src
*** Emacs LISP
**** eval-sexp-fu

Flash some lights when evaluating expressions.

#+begin_src emacs-lisp
(require 'eval-sexp-fu)
(setq eval-sexp-fu-flash-duration 0.4)
(turn-on-eval-sexp-fu-flash-mode)
(key-chord-define lisp-interaction-mode-map "90" 'eval-sexp-fu-eval-sexp-inner-list)
(key-chord-define emacs-lisp-mode-map "90" 'eval-sexp-fu-eval-sexp-inner-list)
(define-key lisp-interaction-mode-map (kbd "C-c C-c") 'eval-sexp-fu-eval-sexp-inner-list)
(define-key lisp-interaction-mode-map (kbd "C-c C-e") 'eval-sexp-fu-eval-sexp-inner-sexp)
(define-key emacs-lisp-mode-map (kbd "C-c C-c") 'eval-sexp-fu-eval-sexp-inner-list)
(define-key emacs-lisp-mode-map (kbd "C-c C-e") 'eval-sexp-fu-eval-sexp-inner-sexp)
#+end_src
**** ielm

IELM is short for Inferior Emacs Lisp Mode. It is a REPL for Emacs Lisp that is sometimes useful if you want to get immediate feedback and a prompt to work with. I tend to use the =*scratch*= buffer for explorations like that usually but would be probably better off to use IELM more often :)

#+begin_src emacs-lisp
(eval-after-load 'ielm
  '(progn
     (add-hook 'inferior-emacs-lisp-mode-hook
               (lambda ()
                 (turn-on-eldoc-mode)))))
#+end_src

We need to tweak IELM a bit so we get completion and eldoc hints.

**** ert-modline

This is a minor mode that will run ERT tests in the background whenever you save an Elisp buffer or evaluate an expression. The results are displayed in the modeline, so you will know immediately if you have introduced a breaking change.

#+begin_src emacs-lisp :tangle yes
(autoload 'ert-modeline-mode "ert-modeline")
(add-hook 'emacs-lisp-mode-hook 'ert-modeline-mode)
#+end_src

*** Python
**** elpy

Elpy makes setting up a great Python IDE a breeze. It's written by [[http://www.jorgenschaefer.de/][Jorgen Schäfer]] also known as =forcer=.

Github: https://github.com/jorgenschaefer/elpy

#+begin_src emacs-lisp
;; Support for pyenv
(defvar pyenv-path "~/.pyenv"
  "pyenv root directory.")

(setq elpy-rpc-backend "jedi")

(when (file-exists-p pyenv-path)
  (let ((bin-path (concat pyenv-path "/bin"))
        (shims-path (concat pyenv-path "/shims")))
    (setenv "PATH"
            (concat bin-path ":" shims-path ":"
                    (getenv "PATH")))
    (setq python-check-command (concat shims-path "/flake8"))
    (setq elpy-rpc-python-command (concat shims-path "/python"))))

(elpy-enable)
(delq 'flymake-mode elpy-default-minor-modes)

(elpy-use-ipython)
#+end_src

I'm using =flycheck= so please don't use =flymake= (which is old and bugly). Also RET should trigger completion for me and not a newline.
*** Haskell
**** haskell-mode

#+begin_src emacs-lisp
(require 'haskell-mode)
(setq haskell-indent-thenelse 3)
(add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
(add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
#+end_src
*** Javascript
**** js2-mode

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))

(setq js2-allow-rhino-new-expr-initializer nil)
(setq js2-auto-indent-p nil)
(setq js2-enter-indents-newline nil)
(setq js2-global-externs '("module" "require" "buster" "sinon" "assert" "refute" "setTimeout" "clearTimeout" "setInterval" "clearInterval" "location" "__dirname" "console" "JSON"))
(setq js2-idle-timer-delay 0.1)
(setq js2-indent-on-enter-key nil)
(setq js2-mirror-mode nil)
(setq js2-strict-inconsistent-return-warning nil)
(setq js2-auto-indent-p t)
(setq js2-include-rhino-externs nil)
(setq js2-include-gears-externs nil)
(setq js2-concat-multiline-strings 'eol)
(setq js2-rebind-eol-bol-keys nil)
(setq js2-mode-show-parse-errors nil)
(setq js2-mode-show-strict-warnings nil)

(add-hook 'js2-mode-hook (lambda () (flycheck-mode 1)))
#+end_src

Got most of that from [[https://github.com/magnars/.emacs.d/blob/master/setup-js2-mode.el][Magnars' .emacs.d]].
**** json-mode

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.json\\'" . json-mode))
#+end_src

=json-mode= adds a bit better syntax highlighting for =.json= files.
**** skewer

#+BEGIN_QUOTE
Provides live interaction with JavaScript, CSS, and HTML in a web browser. Expressions are sent on-the-fly from an editing buffer to be evaluated in the browser, just like Emacs does with an inferior Lisp process in Lisp modes.
#+END_QUOTE

The following bookmarklet will load skewer on demand on any website:

#+begin_src js
javascript:(function) {
    var d=document;
    var s=d.createElement('script');
    s.src='http://localhost:8080/skewer';
    d.body.appendChild(s);
})()
#+end_src

Instructions and the source code can be found [[https://github.com/skeeto/skewer-mode][on Github]].

#+begin_src emacs-lisp
(skewer-setup)
#+end_src
*** Markdown

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
#+end_src

Enable markdown-mode when the file suffixes match.

*** Ruby
**** robe

Advanced autocompletion for Ruby

#+begin_src emacs-lisp
(add-hook 'ruby-mode-hook
          (lambda ()
            (robe-mode 1)
            (push 'company-robe company-backends)))
#+end_src
*** HTML+js
**** sgml

#+begin_src emacs-lisp
(setq sgml-basic-offset 4)
(add-hook 'sgml-mode-hook 'sgml-electric-tag-pair-mode)
#+end_src

Use 4 spaces for identation and enable =sgml-electric-tag-pair-mode= so that  editing an opening markup tag automatically updates the closing tag.
**** web-mode
#+BEGIN_QUOTE
web-mode.el is an autonomous emacs major-mode for editing web templates:
HTML documents embedding parts (CSS / JavaScript) and blocks (client/server side)
#+END_QUOTE

Homepage: http://web-mode.org/
Github: https://github.com/fxbois/web-mode

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
(defun my-font-lock-mode-setup ()
  (when (equal major-mode 'web-mode) (setq font-lock-mode nil)))
(add-hook 'font-lock-mode-hook 'my-font-lock-mode-setup)
#+end_src

Enable web-mode for html buffers. Disable font-locking in web-mode because it's conflicting with other modes that do font-locking.

** Evil - make an Emacs into a better VIM
*** Basics:

#+begin_src emacs-lisp
(require 'evil)
(evil-mode 1)

;; Bring back normal cursor
;;(setq evil-default-cursor nil)

(setq evil-default-state 'normal)

(setq evil-mode-line-format nil)

;Disable evil in special buffers
(loop for (mode . state) in '((inferior-emacs-lisp-mode . emacs)
                              (pylookup-mode . emacs)
                              (comint-mode . emacs)
                              (ebib-entry-mode . emacs)
                              (ebib-index-mode . emacs)
                              (ebib-log-mode . emacs)
                              (gtags-select-mode . emacs)
                              (shell-mode . emacs)
                              (term-mode . emacs)
                              (bc-menu-mode . emacs)
                              (magit-branch-manager-mode . emacs)
                              (semantic-symref-results-mode . emacs)
                              (rdictcc-buffer-mode . emacs))
      do (evil-set-initial-state mode state))

;;Escape should quit whatever it can
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)

;; This will make Enter properly indent when needed
(define-key evil-insert-state-map [remap newline] 'evil-ret)

#+end_src

*** Evil Leader

Enable <Leader>. Set the <Leade> key to ; ( on home row )

#+begin_src emacs-lisp
(global-evil-leader-mode)
(setq evil-leader/leader ";" evil-leader/in-all-states t)
#+end_src

*** Evil Surround
#+begin_src emacs-lisp
(global-surround-mode 1)
#+end_src

*** Evil Matchit
#+begin_src emacs-lisp
(global-evil-matchit-mode 1)
#+end_src

*** Evil Nerd Commenter

#+begin_src emacs-lisp
(evil-leader/set-key "ci" 'evilnc-comment-or-uncomment-lines)
(evil-leader/set-key "cl" 'evilnc-comment-or-uncomment-to-the-line)
(evil-leader/set-key "cc" 'evilnc-copy-and-comment-lines)
(evil-leader/set-key "cp" 'evilnc-comment-or-uncomment-paragraphs)
(evil-leader/set-key "cr" 'comment-or-uncomment-region)

#+end_src

*** Evil Exchange
#+begin_src emacs-lisp
;;(evil-exchange-install)
#+end_src

*** Evil Extra Operator
#+begin_src emacs-lisp
;;(global-evil-extra-operator-mode 1)
#+end_src

*** Evil Plugins
#+begin_src emacs-lisp

#+end_src

*** Evil Ace Jump
AceJump is a nice addition to evil's standard motions.

The following definitions are necessary to define evil motions for ace-jump-mode (version 2).

ace-jump is actually a series of commands which makes handling by evil
difficult (and with some other things as well), using this macro we let it
appear as one.

#+begin_src emacs-lisp
(when (require 'ace-jump-mode nil 'noerror)
(defmacro evil-enclose-ace-jump (&rest body)
  `(let ((old-mark (mark)))
     (remove-hook 'pre-command-hook #'evil-visual-pre-command t)
     (remove-hook 'post-command-hook #'evil-visual-post-command t)
     (unwind-protect
         (progn
           ,@body
           (recursive-edit))
       (if (evil-visual-state-p)
           (progn
             (add-hook 'pre-command-hook #'evil-visual-pre-command nil t)
             (add-hook 'post-command-hook #'evil-visual-post-command nil t)
             (set-mark old-mark))
         (push-mark old-mark)))))

(evil-define-motion evil-ace-jump-char-mode (count)
  :type exclusive
  (evil-enclose-ace-jump
   (ace-jump-mode 5)))

(evil-define-motion evil-ace-jump-line-mode (count)
  :type line
  (evil-enclose-ace-jump
   (ace-jump-mode 9)))

(evil-define-motion evil-ace-jump-word-mode (count)
  :type exclusive
  (evil-enclose-ace-jump
   (ace-jump-mode 1)))

(evil-define-motion evil-ace-jump-char-to-mode (count)
  :type exclusive
  (evil-enclose-ace-jump
   (ace-jump-mode 5)
   (forward-char -1))))

;; Set keybindings for ace-mode
(evil-leader/set-key
  "jc" 'evil-ace-jump-char-mode
  "jw" 'evil-ace-jump-word-mode
  "jl" 'evil-ace-jump-line-mode)
#+end_src

*** Custom key bindings

Those are cusom bindings that I use.

TODO move evil bindings to separate table

#+begin_src emacs-lisp
;;Use <Leader>, to bring up emacs command
(evil-leader/set-key "," 'smex)

;; Emulate some behavior of Lusty*

;; Leader lb - ido buffers lf - ido files
(evil-leader/set-key "lb" 'ido-switch-buffer)
(evil-leader/set-key "lB" 'ibuffer)

(evil-leader/set-key "lf" 'ido-find-file)
(evil-leader/set-key "lr" 'recentf-ido-find-file)

;; Projectile
(evil-leader/set-key "pf" 'projectile-find-file)
(evil-leader/set-key "pr" 'projectile-recentf)
(evil-leader/set-key "po" 'projectile-multioccur)

(evil-leader/set-key "ld" 'cd)


;; simulate vim's "nnoremap <space> 10jzz"
(define-key evil-normal-state-map " " (lambda ()
                                        (interactive)
                                        (next-line 10)
                                        (evil-scroll-line-down 10)))

;; Use = to indent region - very useful
(define-key evil-normal-state-map "=" 'indent-region)

;; simulate vim's "nnoremap <backspace> 10kzz"
(define-key evil-normal-state-map [backspace] (lambda ()
                                                (interactive)
                                                (previous-line 10)
                                                (evil-scroll-line-up 10)))

;; Working with splits
(evil-leader/set-key "|" 'split-window-horizontally )
(evil-leader/set-key "\\" 'split-window-vertically)

;; Use Shift-arrows to move around splits
(windmove-default-keybindings)

;; Magit status screen
(evil-leader/set-key "gs" 'magit-status)

;;Undo tree
(evil-leader/set-key "u" 'undo-tree-visualize)

;; Super escape using chords
(key-chord-define-global "jk"  'evil-normal-state) ; super ESC
(key-chord-define-global "JK"  'evil-emacs-state)

;; ;; Use DASH for documentaton
(define-key evil-normal-state-map (kbd "?") 'dash-at-point)

;; Some commands
(evil-ex-define-cmd "killb" 'kill-other-buffers)
#+end_src

** Sublime and other friends

Collection of things that I liked from other editors.

*** Shift-Cmd-P from Sublime ( command palette )

Can be emulated by grizzlr or ido

#+begin_src emacs-lisp
(defun sublime-csp ()
  (interactive)
  (call-interactively
   (intern
    (completing-read
     "C-S-p"
     (all-completions "" obarray 'commandp)))))
#+end_src

** Load minor mode with all the keybindings we've set

*** my-keys-minor-mode

#+begin_src emacs-lisp
(define-minor-mode my-keys-minor-mode
  "A minor mode so that my key settings override annoying major modes."
  t " K" 'my-keys-minor-mode-map)
(my-keys-minor-mode 1)
#+end_src

** Post - init

Here I put all the stuff which should be done after all major and minor modes are loaded.

*** Modeline - some modeline clutter cleanup

This is a clean-up of the modeline, the idea coming from [[http://amitp.blogspot.co.il/2011/08/emacs-custom-mode-line.html][Amit Patel's blog post]]
Mainly, I liked his idea to remove all the clutter and make minor modes almost invisible. It requires VC mode to be loaded. The proper way to do that would be to factor it out to separate module

#+begin_src emacs-lisp :tangle yes
  ;; Extra mode line faces
  (make-face 'mode-line-read-only-face)
  (make-face 'mode-line-modified-face)
  (make-face 'mode-line-folder-face)
  (make-face 'mode-line-filename-face)
  (make-face 'mode-line-position-face)
  (make-face 'mode-line-mode-face)
  (make-face 'mode-line-minor-mode-face)
  (make-face 'mode-line-process-face)
  (make-face 'mode-line-80col-face)

  (set-face-attribute 'mode-line nil
                      :inverse-video nil
                      ;; :box '(:line-width 1 :style nil)
                      )
  (set-face-attribute 'mode-line-inactive nil
                      :inverse-video nil
                      ;; :box '(:line-width 1 :style nil)
                      )
  (set-face-attribute 'mode-line-read-only-face nil
                      :inherit 'mode-line-face
                      :foreground "#4271ae")
  (set-face-attribute 'mode-line-modified-face nil
                      :inherit 'mode-line-face
                      :foreground "#c82829")
  (set-face-attribute 'mode-line-folder-face nil
                      :inherit 'mode-line-face)
  (set-face-attribute 'mode-line-filename-face nil
                      :inherit 'mode-line-face
                      :weight 'bold)
  (set-face-attribute 'mode-line-position-face nil
                      :inherit 'mode-line-face
                      :height 100)
  (set-face-attribute 'mode-line-mode-face nil
                      :inherit 'mode-line-face)
  (set-face-attribute 'mode-line-minor-mode-face nil
                      :inherit 'mode-line-mode-face
                      :height 90)
  (set-face-attribute 'mode-line-process-face nil
                      :inherit 'mode-line-face)
  (set-face-attribute 'mode-line-80col-face nil
                      :inherit 'mode-line-position-face)

  ;; Helper function
  (defun shorten-directory (dir max-length)
    "Show up to `max-length' characters of a directory name `dir'."
    (let ((path (reverse (split-string (abbreviate-file-name dir) "/")))
          (output ""))
      (when (and path (equal "" (car path)))
        (setq path (cdr path)))
      (while (and path (< (length output) (- max-length 4)))
        (setq output (concat (car path) "/" output))
        (setq path (cdr path)))
      (when path
        (setq output (concat ".../" output)))
      output))


  ;; Mode line setup
  (setq-default mode-line-format
                '(; Position, including warning for 80 columns
                  (:propertize "%4l:" face mode-line-position-face)
                  (:eval (propertize "%3c" 'face
                                     (if (>= (current-column) 80)
                                         'mode-line-80col-face
                                       'mode-line-position-face)))
                                          ; emacsclient [default -- keep?]
                  mode-line-client
                  "  "
                                          ; read-only or modified status
                  (:eval
                   (cond (buffer-read-only
                          (propertize " RO " 'face 'mode-line-read-only-face))
                         ((buffer-modified-p)
                          (propertize " ** " 'face 'mode-line-modified-face))
                         (t "      ")))
                  "    "
                                          ; directory and buffer/file name
                  (:propertize (:eval (shorten-directory default-directory 30))
                               face mode-line-folder-face)
                  (:propertize "%b"
                               face mode-line-filename-face)
                                          ;; narrow [default -- keep?]
                  " %n "
                                          ;; mode indicators: vc, recursive edit, major mode, minor modes, process, global
                  (vc-mode vc-mode)
                  "  %["
                  (:propertize mode-name
                               face mode-line-mode-face)
                  "%] "
                  (:eval (propertize (format-mode-line minor-mode-alist)
                                     'face 'mode-line-minor-mode-face))
                  (:propertize mode-line-process
                               face mode-line-process-face)
                  (global-mode-string global-mode-string)
                  "    "
                  ))


#+end_src

** Allow for user and host local configuration - they can override everything

This could help to quickly change something locally, or per host

#+begin_src emacs-lisp
(when (file-readable-p "~/.user.el") (load "~/.user.el"))
(when (file-readable-p "~/.local.el") (load "~/.local.el"))
#+end_src


* End                                                      :noexport:ARCHIVE:
